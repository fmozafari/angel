<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cudd: cudd/cuddCompose.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cudd
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">The University of Colorado Decision Diagram Package</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_3b2091e045759846649695fb574cbfc8.html">cudd</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cuddCompose.c File Reference<div class="ingroups"><a class="el" href="group__cudd.html">cudd</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Functional composition and variable permutation of DDs.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="util_8h_source.html">util.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cuddInt_8h_source.html">cuddInt.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for cuddCompose.c:</div>
<div class="dyncontent">
<div class="center"><img src="cuddCompose_8c__incl.png" border="0" usemap="#cudd_2cuddCompose_8c" alt=""/></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab5ccb7b9d27d9d383d0f407cf894f118"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#ab5ccb7b9d27d9d383d0f407cf894f118">Cudd_bddCompose</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, int v)</td></tr>
<tr class="memdesc:ab5ccb7b9d27d9d383d0f407cf894f118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes g for x_v in the BDD for f.  <a href="#ab5ccb7b9d27d9d383d0f407cf894f118">More...</a><br /></td></tr>
<tr class="separator:ab5ccb7b9d27d9d383d0f407cf894f118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad050bd964c7386f2a9eed09b8a1d25d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#ad050bd964c7386f2a9eed09b8a1d25d7">Cudd_addCompose</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, int v)</td></tr>
<tr class="memdesc:ad050bd964c7386f2a9eed09b8a1d25d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes g for x_v in the ADD for f.  <a href="#ad050bd964c7386f2a9eed09b8a1d25d7">More...</a><br /></td></tr>
<tr class="separator:ad050bd964c7386f2a9eed09b8a1d25d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4926a513ab721d9bbc866740d40cbfcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf">Cudd_addPermute</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, int *permut)</td></tr>
<tr class="memdesc:a4926a513ab721d9bbc866740d40cbfcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the variables of an ADD.  <a href="#a4926a513ab721d9bbc866740d40cbfcf">More...</a><br /></td></tr>
<tr class="separator:a4926a513ab721d9bbc866740d40cbfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab066ce29ac83aa7d3891b96d4356e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a2ab066ce29ac83aa7d3891b96d4356e1">Cudd_addSwapVariables</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **x, <a class="el" href="structDdNode.html">DdNode</a> **y, int n)</td></tr>
<tr class="memdesc:a2ab066ce29ac83aa7d3891b96d4356e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two sets of variables of the same size (x and y) in the ADD f.  <a href="#a2ab066ce29ac83aa7d3891b96d4356e1">More...</a><br /></td></tr>
<tr class="separator:a2ab066ce29ac83aa7d3891b96d4356e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa877bf86c670ea10d67d4f6e91fcc98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98">Cudd_bddPermute</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, int *permut)</td></tr>
<tr class="memdesc:afa877bf86c670ea10d67d4f6e91fcc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the variables of a BDD.  <a href="#afa877bf86c670ea10d67d4f6e91fcc98">More...</a><br /></td></tr>
<tr class="separator:afa877bf86c670ea10d67d4f6e91fcc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b6ff390b8f205a28d2804d723118d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#af1b6ff390b8f205a28d2804d723118d9">Cudd_bddVarMap</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:af1b6ff390b8f205a28d2804d723118d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remaps the variables of a BDD using the default variable map.  <a href="#af1b6ff390b8f205a28d2804d723118d9">More...</a><br /></td></tr>
<tr class="separator:af1b6ff390b8f205a28d2804d723118d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0ed2b9c7a7158ed78273908a2a5386"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a3d0ed2b9c7a7158ed78273908a2a5386">Cudd_SetVarMap</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> **x, <a class="el" href="structDdNode.html">DdNode</a> **y, int n)</td></tr>
<tr class="memdesc:a3d0ed2b9c7a7158ed78273908a2a5386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a variable mapping with the manager.  <a href="#a3d0ed2b9c7a7158ed78273908a2a5386">More...</a><br /></td></tr>
<tr class="separator:a3d0ed2b9c7a7158ed78273908a2a5386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab6b6123e102f9b0b61c9d2961f707e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a2ab6b6123e102f9b0b61c9d2961f707e">Cudd_bddSwapVariables</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **x, <a class="el" href="structDdNode.html">DdNode</a> **y, int n)</td></tr>
<tr class="memdesc:a2ab6b6123e102f9b0b61c9d2961f707e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two sets of variables of the same size (x and y) in the BDD f.  <a href="#a2ab6b6123e102f9b0b61c9d2961f707e">More...</a><br /></td></tr>
<tr class="separator:a2ab6b6123e102f9b0b61c9d2961f707e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e976b573531badb9a023f86dcdbeb40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a6e976b573531badb9a023f86dcdbeb40">Cudd_bddAdjPermuteX</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *B, <a class="el" href="structDdNode.html">DdNode</a> **x, int n)</td></tr>
<tr class="memdesc:a6e976b573531badb9a023f86dcdbeb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearranges a set of variables in the BDD B.  <a href="#a6e976b573531badb9a023f86dcdbeb40">More...</a><br /></td></tr>
<tr class="separator:a6e976b573531badb9a023f86dcdbeb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62543c529dab3780047f2a45f1e5c50f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a62543c529dab3780047f2a45f1e5c50f">Cudd_addVectorCompose</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vector)</td></tr>
<tr class="memdesc:a62543c529dab3780047f2a45f1e5c50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes an ADD with a vector of 0-1 ADDs.  <a href="#a62543c529dab3780047f2a45f1e5c50f">More...</a><br /></td></tr>
<tr class="separator:a62543c529dab3780047f2a45f1e5c50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d52f7db30965ff17d5a8d5667162eb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a0d52f7db30965ff17d5a8d5667162eb5">Cudd_addGeneralVectorCompose</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vectorOn, <a class="el" href="structDdNode.html">DdNode</a> **vectorOff)</td></tr>
<tr class="memdesc:a0d52f7db30965ff17d5a8d5667162eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes an ADD with a vector of ADDs.  <a href="#a0d52f7db30965ff17d5a8d5667162eb5">More...</a><br /></td></tr>
<tr class="separator:a0d52f7db30965ff17d5a8d5667162eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74339b069aaea8dbf1b321eaa773b59a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a74339b069aaea8dbf1b321eaa773b59a">Cudd_addNonSimCompose</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vector)</td></tr>
<tr class="memdesc:a74339b069aaea8dbf1b321eaa773b59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes an ADD with a vector of 0-1 ADDs.  <a href="#a74339b069aaea8dbf1b321eaa773b59a">More...</a><br /></td></tr>
<tr class="separator:a74339b069aaea8dbf1b321eaa773b59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bffb3a79510753ee6648a998aaaae97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a0bffb3a79510753ee6648a998aaaae97">Cudd_bddVectorCompose</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vector)</td></tr>
<tr class="memdesc:a0bffb3a79510753ee6648a998aaaae97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a BDD with a vector of BDDs.  <a href="#a0bffb3a79510753ee6648a998aaaae97">More...</a><br /></td></tr>
<tr class="separator:a0bffb3a79510753ee6648a998aaaae97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133d2162f21001ffd87160c1ba9ee761"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a133d2162f21001ffd87160c1ba9ee761">cuddBddComposeRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *proj)</td></tr>
<tr class="memdesc:a133d2162f21001ffd87160c1ba9ee761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_bddCompose.  <a href="#a133d2162f21001ffd87160c1ba9ee761">More...</a><br /></td></tr>
<tr class="separator:a133d2162f21001ffd87160c1ba9ee761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d26ec582df94635299038b44d4cb4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a13d26ec582df94635299038b44d4cb4b">cuddAddComposeRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *proj)</td></tr>
<tr class="memdesc:a13d26ec582df94635299038b44d4cb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_addCompose.  <a href="#a13d26ec582df94635299038b44d4cb4b">More...</a><br /></td></tr>
<tr class="separator:a13d26ec582df94635299038b44d4cb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5857292c431da5fa962b23c0ccabda2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#ab5857292c431da5fa962b23c0ccabda2">cuddAddPermuteRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdHashTable.html">DdHashTable</a> *table, <a class="el" href="structDdNode.html">DdNode</a> *node, int *permut)</td></tr>
<tr class="memdesc:ab5857292c431da5fa962b23c0ccabda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the recursive step of Cudd_addPermute.  <a href="#ab5857292c431da5fa962b23c0ccabda2">More...</a><br /></td></tr>
<tr class="separator:ab5857292c431da5fa962b23c0ccabda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe391f4d9382e7ac57e6bfae5d35eab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#aafe391f4d9382e7ac57e6bfae5d35eab">cuddBddPermuteRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdHashTable.html">DdHashTable</a> *table, <a class="el" href="structDdNode.html">DdNode</a> *node, int *permut)</td></tr>
<tr class="memdesc:aafe391f4d9382e7ac57e6bfae5d35eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the recursive step of Cudd_bddPermute.  <a href="#aafe391f4d9382e7ac57e6bfae5d35eab">More...</a><br /></td></tr>
<tr class="separator:aafe391f4d9382e7ac57e6bfae5d35eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e75c6dca2c43fb15035c0411b6342d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a82e75c6dca2c43fb15035c0411b6342d">cuddBddVarMapRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a82e75c6dca2c43fb15035c0411b6342d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the recursive step of Cudd_bddVarMap.  <a href="#a82e75c6dca2c43fb15035c0411b6342d">More...</a><br /></td></tr>
<tr class="separator:a82e75c6dca2c43fb15035c0411b6342d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0724509f334eefd7b42fb863960fd5ce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a0724509f334eefd7b42fb863960fd5ce">cuddAddVectorComposeRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdHashTable.html">DdHashTable</a> *table, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vector, int deepest)</td></tr>
<tr class="memdesc:a0724509f334eefd7b42fb863960fd5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_addVectorCompose.  <a href="#a0724509f334eefd7b42fb863960fd5ce">More...</a><br /></td></tr>
<tr class="separator:a0724509f334eefd7b42fb863960fd5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad7d5fdbf314bcbb22d0a7f04b63148"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#aaad7d5fdbf314bcbb22d0a7f04b63148">cuddAddGeneralVectorComposeRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdHashTable.html">DdHashTable</a> *table, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vectorOn, <a class="el" href="structDdNode.html">DdNode</a> **vectorOff, int deepest)</td></tr>
<tr class="memdesc:aaad7d5fdbf314bcbb22d0a7f04b63148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_addGeneralVectorCompose.  <a href="#aaad7d5fdbf314bcbb22d0a7f04b63148">More...</a><br /></td></tr>
<tr class="separator:aaad7d5fdbf314bcbb22d0a7f04b63148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bad014827255f25a62c401df4dbd8b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#ac5bad014827255f25a62c401df4dbd8b">cuddAddNonSimComposeRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vector, <a class="el" href="structDdNode.html">DdNode</a> *key, <a class="el" href="structDdNode.html">DdNode</a> *cube, int lastsub)</td></tr>
<tr class="memdesc:ac5bad014827255f25a62c401df4dbd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_addNonSimCompose.  <a href="#ac5bad014827255f25a62c401df4dbd8b">More...</a><br /></td></tr>
<tr class="separator:ac5bad014827255f25a62c401df4dbd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79955dcae643990f810d79bf93fe1f72"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a79955dcae643990f810d79bf93fe1f72">cuddBddVectorComposeRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdHashTable.html">DdHashTable</a> *table, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vector, int deepest)</td></tr>
<tr class="memdesc:a79955dcae643990f810d79bf93fe1f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_bddVectorCompose.  <a href="#a79955dcae643990f810d79bf93fe1f72">More...</a><br /></td></tr>
<tr class="separator:a79955dcae643990f810d79bf93fe1f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2fa818c76d5302d83929ee4402da39"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#aba2fa818c76d5302d83929ee4402da39">ddIsIthAddVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, unsigned int i)</td></tr>
<tr class="memdesc:aba2fa818c76d5302d83929ee4402da39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison of a function to the i-th ADD variable.  <a href="#aba2fa818c76d5302d83929ee4402da39">More...</a><br /></td></tr>
<tr class="separator:aba2fa818c76d5302d83929ee4402da39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af318178b1f1071db47c7e268673b6631"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#af318178b1f1071db47c7e268673b6631">ddIsIthAddVarPair</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, unsigned int i)</td></tr>
<tr class="memdesc:af318178b1f1071db47c7e268673b6631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison of a pair of functions to the i-th ADD variable.  <a href="#af318178b1f1071db47c7e268673b6631">More...</a><br /></td></tr>
<tr class="separator:af318178b1f1071db47c7e268673b6631"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functional composition and variable permutation of DDs. </p>
<p>The permutation functions use a local cache because the results to be remembered depend on the permutation being applied. Since the permutation is just an array, it cannot be stored in the global cache. There are different procedured for BDDs and ADDs. This is because bddPermuteRecur uses cuddBddIteRecur. If this were changed, the procedures could be merged.</p>
<dl class="section author"><dt>Author</dt><dd>Fabio Somenzi and Kavita Ravi</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd><p class="startdd">Copyright (c) 1995-2015, Regents of the University of Colorado</p>
<p class="interdd">All rights reserved.</p>
<p class="interdd">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p class="interdd">Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p class="interdd">Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p class="interdd">Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p class="enddd">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ad050bd964c7386f2a9eed09b8a1d25d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad050bd964c7386f2a9eed09b8a1d25d7">&#9670;&nbsp;</a></span>Cudd_addCompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addCompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes g for x_v in the ADD for f. </p>
<p>v is the index of the variable to be substituted. g must be a 0-1 ADD. Cudd_bddCompose passes the corresponding projection function to the recursive procedure, so that the cache may be used.</p>
<dl class="section return"><dt>Returns</dt><dd>the composed ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#ab5ccb7b9d27d9d383d0f407cf894f118" title="Substitutes g for x_v in the BDD for f.">Cudd_bddCompose</a> </dd></dl>

</div>
</div>
<a id="a0d52f7db30965ff17d5a8d5667162eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d52f7db30965ff17d5a8d5667162eb5">&#9670;&nbsp;</a></span>Cudd_addGeneralVectorCompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addGeneralVectorCompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vectorOn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vectorOff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes an ADD with a vector of ADDs. </p>
<p>Given a vector of ADDs, creates a new ADD by substituting the ADDs for the variables of the ADD f. vectorOn contains ADDs to be substituted for the x_v and vectorOff the ADDs to be substituted for x_v'. There should be an entry in vector for each variable in the manager. If no substitution is sought for a given variable, the corresponding projection function should be specified in the vector. This function implements simultaneous composition.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#a62543c529dab3780047f2a45f1e5c50f" title="Composes an ADD with a vector of 0-1 ADDs.">Cudd_addVectorCompose</a> <a class="el" href="cuddCompose_8c.html#a74339b069aaea8dbf1b321eaa773b59a" title="Composes an ADD with a vector of 0-1 ADDs.">Cudd_addNonSimCompose</a> <a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf" title="Permutes the variables of an ADD.">Cudd_addPermute</a> <a class="el" href="cuddCompose_8c.html#ad050bd964c7386f2a9eed09b8a1d25d7" title="Substitutes g for x_v in the ADD for f.">Cudd_addCompose</a> <a class="el" href="cuddCompose_8c.html#a0bffb3a79510753ee6648a998aaaae97" title="Composes a BDD with a vector of BDDs.">Cudd_bddVectorCompose</a> </dd></dl>

</div>
</div>
<a id="a74339b069aaea8dbf1b321eaa773b59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74339b069aaea8dbf1b321eaa773b59a">&#9670;&nbsp;</a></span>Cudd_addNonSimCompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addNonSimCompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes an ADD with a vector of 0-1 ADDs. </p>
<p>Given a vector of 0-1 ADDs, creates a new ADD by substituting the 0-1 ADDs for the variables of the ADD f. There should be an entry in vector for each variable in the manager. This function implements non-simultaneous composition. If any of the functions being composed depends on any of the variables being substituted, then the result depends on the order of composition, which in turn depends on the variable order: The variables farther from the roots in the order are substituted first.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#a62543c529dab3780047f2a45f1e5c50f" title="Composes an ADD with a vector of 0-1 ADDs.">Cudd_addVectorCompose</a> <a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf" title="Permutes the variables of an ADD.">Cudd_addPermute</a> <a class="el" href="cuddCompose_8c.html#ad050bd964c7386f2a9eed09b8a1d25d7" title="Substitutes g for x_v in the ADD for f.">Cudd_addCompose</a> </dd></dl>

</div>
</div>
<a id="a4926a513ab721d9bbc866740d40cbfcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4926a513ab721d9bbc866740d40cbfcf">&#9670;&nbsp;</a></span>Cudd_addPermute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addPermute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>permut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permutes the variables of an ADD. </p>
<p>Given a permutation in array permut, creates a new ADD with permuted variables. There should be an entry in array permut for each variable in the manager. The i-th entry of permut holds the index of the variable that is to substitute the i-th variable.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab066ce29ac83aa7d3891b96d4356e1" title="Swaps two sets of variables of the same size (x and y) in the ADD f.">Cudd_addSwapVariables</a> </dd></dl>

</div>
</div>
<a id="a2ab066ce29ac83aa7d3891b96d4356e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab066ce29ac83aa7d3891b96d4356e1">&#9670;&nbsp;</a></span>Cudd_addSwapVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addSwapVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps two sets of variables of the same size (x and y) in the ADD f. </p>
<p>The size is given by n. The two sets of variables are assumed to be disjoint.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf" title="Permutes the variables of an ADD.">Cudd_addPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab6b6123e102f9b0b61c9d2961f707e" title="Swaps two sets of variables of the same size (x and y) in the BDD f.">Cudd_bddSwapVariables</a> </dd></dl>

</div>
</div>
<a id="a62543c529dab3780047f2a45f1e5c50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62543c529dab3780047f2a45f1e5c50f">&#9670;&nbsp;</a></span>Cudd_addVectorCompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addVectorCompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes an ADD with a vector of 0-1 ADDs. </p>
<p>Given a vector of 0-1 ADDs, creates a new ADD by substituting the 0-1 ADDs for the variables of the ADD f. There should be an entry in vector for each variable in the manager. If no substitution is sought for a given variable, the corresponding projection function should be specified in the vector. This function implements simultaneous composition.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#a74339b069aaea8dbf1b321eaa773b59a" title="Composes an ADD with a vector of 0-1 ADDs.">Cudd_addNonSimCompose</a> <a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf" title="Permutes the variables of an ADD.">Cudd_addPermute</a> <a class="el" href="cuddCompose_8c.html#ad050bd964c7386f2a9eed09b8a1d25d7" title="Substitutes g for x_v in the ADD for f.">Cudd_addCompose</a> <a class="el" href="cuddCompose_8c.html#a0bffb3a79510753ee6648a998aaaae97" title="Composes a BDD with a vector of BDDs.">Cudd_bddVectorCompose</a> </dd></dl>

</div>
</div>
<a id="a6e976b573531badb9a023f86dcdbeb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e976b573531badb9a023f86dcdbeb40">&#9670;&nbsp;</a></span>Cudd_bddAdjPermuteX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddAdjPermuteX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rearranges a set of variables in the BDD B. </p>
<p>The size of the set is given by n. This procedure is intended for the &lsquo;randomization&rsquo; of the priority functions.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab6b6123e102f9b0b61c9d2961f707e" title="Swaps two sets of variables of the same size (x and y) in the BDD f.">Cudd_bddSwapVariables</a> <a class="el" href="cuddPriority_8c.html#a7ee4055f67c91825ec6edbea00ce9f83" title="Generates a BDD for the function d(x,y) &gt; d(x,z).">Cudd_Dxygtdxz</a> <a class="el" href="cuddPriority_8c.html#ab118ad9c8350d51d5ce1b824db5423fd" title="Generates a BDD for the function d(x,y) &gt; d(y,z).">Cudd_Dxygtdyz</a> <a class="el" href="cuddPriority_8c.html#a939056ced12b4b1d25ea97279b35f941" title="Selects pairs from R using a priority function.">Cudd_PrioritySelect</a> </dd></dl>

</div>
</div>
<a id="ab5ccb7b9d27d9d383d0f407cf894f118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ccb7b9d27d9d383d0f407cf894f118">&#9670;&nbsp;</a></span>Cudd_bddCompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddCompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes g for x_v in the BDD for f. </p>
<p>v is the index of the variable to be substituted. Cudd_bddCompose passes the corresponding projection function to the recursive procedure, so that the cache may be used.</p>
<dl class="section return"><dt>Returns</dt><dd>the composed BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#ad050bd964c7386f2a9eed09b8a1d25d7" title="Substitutes g for x_v in the ADD for f.">Cudd_addCompose</a> </dd></dl>

</div>
</div>
<a id="afa877bf86c670ea10d67d4f6e91fcc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa877bf86c670ea10d67d4f6e91fcc98">&#9670;&nbsp;</a></span>Cudd_bddPermute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddPermute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>permut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permutes the variables of a BDD. </p>
<p>Given a permutation in array permut, creates a new BDD with permuted variables. There should be an entry in array permut for each variable in the manager. The i-th entry of permut holds the index of the variable that is to substitute the i-th variable.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf" title="Permutes the variables of an ADD.">Cudd_addPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab6b6123e102f9b0b61c9d2961f707e" title="Swaps two sets of variables of the same size (x and y) in the BDD f.">Cudd_bddSwapVariables</a> </dd></dl>

</div>
</div>
<a id="a2ab6b6123e102f9b0b61c9d2961f707e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab6b6123e102f9b0b61c9d2961f707e">&#9670;&nbsp;</a></span>Cudd_bddSwapVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddSwapVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps two sets of variables of the same size (x and y) in the BDD f. </p>
<p>The size is given by n. The two sets of variables are assumed to be disjoint.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab066ce29ac83aa7d3891b96d4356e1" title="Swaps two sets of variables of the same size (x and y) in the ADD f.">Cudd_addSwapVariables</a> </dd></dl>

</div>
</div>
<a id="af1b6ff390b8f205a28d2804d723118d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b6ff390b8f205a28d2804d723118d9">&#9670;&nbsp;</a></span>Cudd_bddVarMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddVarMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remaps the variables of a BDD using the default variable map. </p>
<p>A typical use of this function is to swap two sets of variables. The variable map must be registered with Cudd_SetVarMap.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab6b6123e102f9b0b61c9d2961f707e" title="Swaps two sets of variables of the same size (x and y) in the BDD f.">Cudd_bddSwapVariables</a> <a class="el" href="cuddCompose_8c.html#a3d0ed2b9c7a7158ed78273908a2a5386" title="Registers a variable mapping with the manager.">Cudd_SetVarMap</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>DD manager </td></tr>
    <tr><td class="paramname">f</td><td>function in which to remap variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bffb3a79510753ee6648a998aaaae97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bffb3a79510753ee6648a998aaaae97">&#9670;&nbsp;</a></span>Cudd_bddVectorCompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddVectorCompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes a BDD with a vector of BDDs. </p>
<p>Given a vector of BDDs, creates a new BDD by substituting the BDDs for the variables of the BDD f. There should be an entry in vector for each variable in the manager. If no substitution is sought for a given variable, the corresponding projection function should be specified in the vector. This function implements simultaneous composition.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#ab5ccb7b9d27d9d383d0f407cf894f118" title="Substitutes g for x_v in the BDD for f.">Cudd_bddCompose</a> <a class="el" href="cuddCompose_8c.html#a62543c529dab3780047f2a45f1e5c50f" title="Composes an ADD with a vector of 0-1 ADDs.">Cudd_addVectorCompose</a> </dd></dl>

</div>
</div>
<a id="a3d0ed2b9c7a7158ed78273908a2a5386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0ed2b9c7a7158ed78273908a2a5386">&#9670;&nbsp;</a></span>Cudd_SetVarMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_SetVarMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a variable mapping with the manager. </p>
<p>Registers with the manager a variable mapping described by two sets of variables. This variable mapping is then used by functions like Cudd_bddVarMap. This function is convenient for those applications that perform the same mapping several times. However, if several different permutations are used, it may be more efficient not to rely on the registered mapping, because changing mapping causes the cache to be cleared. (The initial setting, however, does not clear the cache.) The two sets of variables (x and y) must have the same size (x and y). The size is given by n. The two sets of variables are normally disjoint, but this restriction is not imposeded by the function. When new variables are created, the map is automatically extended (each new variable maps to itself). The typical use, however, is to wait until all variables are created, and then create the map.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the mapping is successfully registered with the manager; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n Modifies the manager. May clear the cache.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#af1b6ff390b8f205a28d2804d723118d9" title="Remaps the variables of a BDD using the default variable map.">Cudd_bddVarMap</a> <a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab6b6123e102f9b0b61c9d2961f707e" title="Swaps two sets of variables of the same size (x and y) in the BDD f.">Cudd_bddSwapVariables</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>DD manager </td></tr>
    <tr><td class="paramname">x</td><td>first array of variables </td></tr>
    <tr><td class="paramname">y</td><td>second array of variables </td></tr>
    <tr><td class="paramname">n</td><td>length of both arrays </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13d26ec582df94635299038b44d4cb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d26ec582df94635299038b44d4cb4b">&#9670;&nbsp;</a></span>cuddAddComposeRecur()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddAddComposeRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_addCompose. </p>
<dl class="section return"><dt>Returns</dt><dd>the composed BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#ad050bd964c7386f2a9eed09b8a1d25d7" title="Substitutes g for x_v in the ADD for f.">Cudd_addCompose</a> </dd></dl>

</div>
</div>
<a id="aaad7d5fdbf314bcbb22d0a7f04b63148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad7d5fdbf314bcbb22d0a7f04b63148">&#9670;&nbsp;</a></span>cuddAddGeneralVectorComposeRecur()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddAddGeneralVectorComposeRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdHashTable.html">DdHashTable</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vectorOn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vectorOff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deepest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_addGeneralVectorCompose. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">table</td><td>computed table </td></tr>
    <tr><td class="paramname">f</td><td>ADD in which to compose </td></tr>
    <tr><td class="paramname">vectorOn</td><td>functions to substitute for x_i </td></tr>
    <tr><td class="paramname">vectorOff</td><td>functions to substitute for x_i' </td></tr>
    <tr><td class="paramname">deepest</td><td>depth of deepest substitution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5bad014827255f25a62c401df4dbd8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5bad014827255f25a62c401df4dbd8b">&#9670;&nbsp;</a></span>cuddAddNonSimComposeRecur()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddAddNonSimComposeRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lastsub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_addNonSimCompose. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="ab5857292c431da5fa962b23c0ccabda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5857292c431da5fa962b23c0ccabda2">&#9670;&nbsp;</a></span>cuddAddPermuteRecur()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddAddPermuteRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdHashTable.html">DdHashTable</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>permut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the recursive step of Cudd_addPermute. </p>
<p>Recursively puts the ADD in the order given in the array permut. Checks for trivial cases to terminate recursion, then splits on the children of this node. Once the solutions for the children are obtained, it puts into the current position the node from the rest of the ADD that should be here. Then returns this ADD. The key here is that the node being visited is NOT put in its proper place by this instance, but rather is switched when its proper position is reached in the recursion tree.</p>
<p>The <a class="el" href="structDdNode.html" title="Decision diagram node.">DdNode</a> * that is returned is the same ADD as passed in as node, but in the new order.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf" title="Permutes the variables of an ADD.">Cudd_addPermute</a> <a class="el" href="cuddCompose_8c.html#aafe391f4d9382e7ac57e6bfae5d35eab" title="Implements the recursive step of Cudd_bddPermute.">cuddBddPermuteRecur</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>DD manager </td></tr>
    <tr><td class="paramname">table</td><td>computed table </td></tr>
    <tr><td class="paramname">node</td><td>ADD to be reordered </td></tr>
    <tr><td class="paramname">permut</td><td>permutation array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0724509f334eefd7b42fb863960fd5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0724509f334eefd7b42fb863960fd5ce">&#9670;&nbsp;</a></span>cuddAddVectorComposeRecur()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddAddVectorComposeRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdHashTable.html">DdHashTable</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deepest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_addVectorCompose. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">table</td><td>computed table </td></tr>
    <tr><td class="paramname">f</td><td>ADD in which to compose </td></tr>
    <tr><td class="paramname">vector</td><td>functions to substitute </td></tr>
    <tr><td class="paramname">deepest</td><td>depth of deepest substitution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a133d2162f21001ffd87160c1ba9ee761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133d2162f21001ffd87160c1ba9ee761">&#9670;&nbsp;</a></span>cuddBddComposeRecur()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddBddComposeRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_bddCompose. </p>
<p>Exploits the fact that the composition of f' with g produces the complement of the composition of f with g to better utilize the cache.</p>
<dl class="section return"><dt>Returns</dt><dd>the composed BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#ab5ccb7b9d27d9d383d0f407cf894f118" title="Substitutes g for x_v in the BDD for f.">Cudd_bddCompose</a> </dd></dl>

</div>
</div>
<a id="aafe391f4d9382e7ac57e6bfae5d35eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe391f4d9382e7ac57e6bfae5d35eab">&#9670;&nbsp;</a></span>cuddBddPermuteRecur()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddBddPermuteRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdHashTable.html">DdHashTable</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>permut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the recursive step of Cudd_bddPermute. </p>
<p>Recursively puts the BDD in the order given in the array permut. Checks for trivial cases to terminate recursion, then splits on the children of this node. Once the solutions for the children are obtained, it puts into the current position the node from the rest of the BDD that should be here. Then returns this BDD. The key here is that the node being visited is NOT put in its proper place by this instance, but rather is switched when its proper position is reached in the recursion tree.</p>
<p>The <a class="el" href="structDdNode.html" title="Decision diagram node.">DdNode</a> * that is returned is the same BDD as passed in as node, but in the new order.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#ab5857292c431da5fa962b23c0ccabda2" title="Implements the recursive step of Cudd_addPermute.">cuddAddPermuteRecur</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>DD manager </td></tr>
    <tr><td class="paramname">table</td><td>computed table </td></tr>
    <tr><td class="paramname">node</td><td>BDD to be reordered </td></tr>
    <tr><td class="paramname">permut</td><td>permutation array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82e75c6dca2c43fb15035c0411b6342d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e75c6dca2c43fb15035c0411b6342d">&#9670;&nbsp;</a></span>cuddBddVarMapRecur()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddBddVarMapRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the recursive step of Cudd_bddVarMap. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#af1b6ff390b8f205a28d2804d723118d9" title="Remaps the variables of a BDD using the default variable map.">Cudd_bddVarMap</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>DD manager </td></tr>
    <tr><td class="paramname">f</td><td>BDD to be remapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79955dcae643990f810d79bf93fe1f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79955dcae643990f810d79bf93fe1f72">&#9670;&nbsp;</a></span>cuddBddVectorComposeRecur()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddBddVectorComposeRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdHashTable.html">DdHashTable</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deepest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_bddVectorCompose. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">table</td><td>computed table </td></tr>
    <tr><td class="paramname">f</td><td>BDD in which to compose </td></tr>
    <tr><td class="paramname">vector</td><td>functions to be composed </td></tr>
    <tr><td class="paramname">deepest</td><td>depth of the deepest substitution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba2fa818c76d5302d83929ee4402da39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2fa818c76d5302d83929ee4402da39">&#9670;&nbsp;</a></span>ddIsIthAddVar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int ddIsIthAddVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison of a function to the i-th ADD variable. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the function is the i-th ADD variable; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="af318178b1f1071db47c7e268673b6631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af318178b1f1071db47c7e268673b6631">&#9670;&nbsp;</a></span>ddIsIthAddVarPair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int ddIsIthAddVarPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison of a pair of functions to the i-th ADD variable. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the functions are the i-th ADD variable and its complement; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 2 2019 17:00:50 for cudd by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>

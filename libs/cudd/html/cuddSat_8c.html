<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cudd: cudd/cuddSat.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cudd
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">The University of Colorado Decision Diagram Package</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_3b2091e045759846649695fb574cbfc8.html">cudd</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cuddSat.c File Reference<div class="ingroups"><a class="el" href="group__cudd.html">cudd</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions for the solution of satisfiability related problems.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="util_8h_source.html">util.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cuddInt_8h_source.html">cuddInt.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for cuddSat.c:</div>
<div class="dyncontent">
<div class="center"><img src="cuddSat_8c__incl.png" border="0" usemap="#cudd_2cuddSat_8c" alt=""/></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcuddPathPair.html">cuddPathPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of item stored in memoization table.  <a href="structcuddPathPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6994699d7a2a82b8f838e9d8d408095a"><td class="memItemLeft" align="right" valign="top"><a id="a6994699d7a2a82b8f838e9d8d408095a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DD_BIGGY</b>&#160;&#160;&#160;100000000</td></tr>
<tr class="separator:a6994699d7a2a82b8f838e9d8d408095a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c21b2677d4dc06dfd0dd175bb1a718"><td class="memItemLeft" align="right" valign="top"><a id="aa0c21b2677d4dc06dfd0dd175bb1a718"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>WEIGHT</b>(weight,  col)&#160;&#160;&#160;((weight) == NULL ? 1 : weight[col])</td></tr>
<tr class="separator:aa0c21b2677d4dc06dfd0dd175bb1a718"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9652826593b0f67d77dc1152dacb93f7"><td class="memItemLeft" align="right" valign="top"><a id="a9652826593b0f67d77dc1152dacb93f7"></a>
typedef struct <a class="el" href="structcuddPathPair.html">cuddPathPair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a9652826593b0f67d77dc1152dacb93f7">cuddPathPair</a></td></tr>
<tr class="memdesc:a9652826593b0f67d77dc1152dacb93f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of item stored in memoization table. <br /></td></tr>
<tr class="separator:a9652826593b0f67d77dc1152dacb93f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0f11262fedecf0c0f4376432b478e6e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a0f11262fedecf0c0f4376432b478e6e8">Cudd_Eval</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int *inputs)</td></tr>
<tr class="memdesc:a0f11262fedecf0c0f4376432b478e6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a DD for a given variable assignment.  <a href="#a0f11262fedecf0c0f4376432b478e6e8">More...</a><br /></td></tr>
<tr class="separator:a0f11262fedecf0c0f4376432b478e6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e2d36d1fdfa3d917ad345867bd4596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a78e2d36d1fdfa3d917ad345867bd4596">Cudd_ShortestPath</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, int *weight, int *support, int *length)</td></tr>
<tr class="memdesc:a78e2d36d1fdfa3d917ad345867bd4596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a shortest path in a DD.  <a href="#a78e2d36d1fdfa3d917ad345867bd4596">More...</a><br /></td></tr>
<tr class="separator:a78e2d36d1fdfa3d917ad345867bd4596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5722a5bf76d99cd30783ad87ba03bf96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a5722a5bf76d99cd30783ad87ba03bf96">Cudd_LargestCube</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, int *length)</td></tr>
<tr class="memdesc:a5722a5bf76d99cd30783ad87ba03bf96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a largest cube in a DD.  <a href="#a5722a5bf76d99cd30783ad87ba03bf96">More...</a><br /></td></tr>
<tr class="separator:a5722a5bf76d99cd30783ad87ba03bf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfc0e508dfd1d0bd0c74104a3dd15e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#addfc0e508dfd1d0bd0c74104a3dd15e8">Cudd_ShortestLength</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, int *weight)</td></tr>
<tr class="memdesc:addfc0e508dfd1d0bd0c74104a3dd15e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the shortest path(s) in a DD.  <a href="#addfc0e508dfd1d0bd0c74104a3dd15e8">More...</a><br /></td></tr>
<tr class="separator:addfc0e508dfd1d0bd0c74104a3dd15e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a70b011fca8b95fbc3953e8b1be1fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a66a70b011fca8b95fbc3953e8b1be1fe">Cudd_Decreasing</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int i)</td></tr>
<tr class="memdesc:a66a70b011fca8b95fbc3953e8b1be1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a BDD is negative unate in a variable.  <a href="#a66a70b011fca8b95fbc3953e8b1be1fe">More...</a><br /></td></tr>
<tr class="separator:a66a70b011fca8b95fbc3953e8b1be1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f87b23df844d48727ee53f75d868be6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a4f87b23df844d48727ee53f75d868be6">Cudd_Increasing</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int i)</td></tr>
<tr class="memdesc:a4f87b23df844d48727ee53f75d868be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a BDD is positive unate in a variable.  <a href="#a4f87b23df844d48727ee53f75d868be6">More...</a><br /></td></tr>
<tr class="separator:a4f87b23df844d48727ee53f75d868be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e078600dd9087c623e1bdfea00d599d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a3e078600dd9087c623e1bdfea00d599d">Cudd_EquivDC</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *F, <a class="el" href="structDdNode.html">DdNode</a> *G, <a class="el" href="structDdNode.html">DdNode</a> *D)</td></tr>
<tr class="memdesc:a3e078600dd9087c623e1bdfea00d599d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether F and G are identical wherever D is 0.  <a href="#a3e078600dd9087c623e1bdfea00d599d">More...</a><br /></td></tr>
<tr class="separator:a3e078600dd9087c623e1bdfea00d599d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcbf450b32f6937bc6dba252474638d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a5dcbf450b32f6937bc6dba252474638d">Cudd_bddLeqUnless</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *D)</td></tr>
<tr class="memdesc:a5dcbf450b32f6937bc6dba252474638d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether f is less than of equal to G unless D is 1.  <a href="#a5dcbf450b32f6937bc6dba252474638d">More...</a><br /></td></tr>
<tr class="separator:a5dcbf450b32f6937bc6dba252474638d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0be57ead326db49e00a51d7acf75f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#abe0be57ead326db49e00a51d7acf75f9">Cudd_EqualSupNorm</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> tolerance, int pr)</td></tr>
<tr class="memdesc:abe0be57ead326db49e00a51d7acf75f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ADDs for equality within tolerance.  <a href="#abe0be57ead326db49e00a51d7acf75f9">More...</a><br /></td></tr>
<tr class="separator:abe0be57ead326db49e00a51d7acf75f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b924211354f5d356009a7c804be2340"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a7b924211354f5d356009a7c804be2340">Cudd_bddMakePrime</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *cube, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a7b924211354f5d356009a7c804be2340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands cube to a prime implicant of f.  <a href="#a7b924211354f5d356009a7c804be2340">More...</a><br /></td></tr>
<tr class="separator:a7b924211354f5d356009a7c804be2340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb9bb89f75fe6176be961c73a19be09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#accb9bb89f75fe6176be961c73a19be09">Cudd_bddMaximallyExpand</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *lb, <a class="el" href="structDdNode.html">DdNode</a> *ub, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:accb9bb89f75fe6176be961c73a19be09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands lb to prime implicants of (f and ub).  <a href="#accb9bb89f75fe6176be961c73a19be09">More...</a><br /></td></tr>
<tr class="separator:accb9bb89f75fe6176be961c73a19be09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a45afd92abdea6f969399e7c0eb5c8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a3a45afd92abdea6f969399e7c0eb5c8f">Cudd_bddLargestPrimeUnate</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *phaseBdd)</td></tr>
<tr class="memdesc:a3a45afd92abdea6f969399e7c0eb5c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a largest prime implicant of a unate function.  <a href="#a3a45afd92abdea6f969399e7c0eb5c8f">More...</a><br /></td></tr>
<tr class="separator:a3a45afd92abdea6f969399e7c0eb5c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1ef5892f9b1b85a2766956fca9761c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#aad1ef5892f9b1b85a2766956fca9761c">cuddBddMakePrime</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *cube, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:aad1ef5892f9b1b85a2766956fca9761c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_bddMakePrime.  <a href="#aad1ef5892f9b1b85a2766956fca9761c">More...</a><br /></td></tr>
<tr class="separator:aad1ef5892f9b1b85a2766956fca9761c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e5bbe63d2e2598f123244b9789a731"><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="st_8h.html#a0c6a172fd99de7928916e65034ed8b1f">st_retval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a93e5bbe63d2e2598f123244b9789a731">freePathPair</a> (void *key, void *value, void *arg)</td></tr>
<tr class="memdesc:a93e5bbe63d2e2598f123244b9789a731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the entries of the visited symbol table.  <a href="#a93e5bbe63d2e2598f123244b9789a731">More...</a><br /></td></tr>
<tr class="separator:a93e5bbe63d2e2598f123244b9789a731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efd005d08ed4ed56179d0f0970bb2e7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structcuddPathPair.html">cuddPathPair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a3efd005d08ed4ed56179d0f0970bb2e7">getShortest</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *root, int *cost, int *support, <a class="el" href="structst__table.html">st_table</a> *visited)</td></tr>
<tr class="memdesc:a3efd005d08ed4ed56179d0f0970bb2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the length of the shortest path(s) in a DD.  <a href="#a3efd005d08ed4ed56179d0f0970bb2e7">More...</a><br /></td></tr>
<tr class="separator:a3efd005d08ed4ed56179d0f0970bb2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9238a0ffa82b4ae18aec7a04ddcca24"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#aa9238a0ffa82b4ae18aec7a04ddcca24">getPath</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structst__table.html">st_table</a> *visited, <a class="el" href="structDdNode.html">DdNode</a> *f, int *weight, int cost)</td></tr>
<tr class="memdesc:aa9238a0ffa82b4ae18aec7a04ddcca24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a BDD for a shortest path of f.  <a href="#aa9238a0ffa82b4ae18aec7a04ddcca24">More...</a><br /></td></tr>
<tr class="separator:aa9238a0ffa82b4ae18aec7a04ddcca24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6ca667c717978d9377526b5466bb24"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structcuddPathPair.html">cuddPathPair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a8c6ca667c717978d9377526b5466bb24">getLargest</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *root, <a class="el" href="structst__table.html">st_table</a> *visited)</td></tr>
<tr class="memdesc:a8c6ca667c717978d9377526b5466bb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the size of the largest cube(s) in a DD.  <a href="#a8c6ca667c717978d9377526b5466bb24">More...</a><br /></td></tr>
<tr class="separator:a8c6ca667c717978d9377526b5466bb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6c71713bfc3fc3e45e71f63c729c4d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a0b6c71713bfc3fc3e45e71f63c729c4d">getCube</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structst__table.html">st_table</a> *visited, <a class="el" href="structDdNode.html">DdNode</a> *f, int cost)</td></tr>
<tr class="memdesc:a0b6c71713bfc3fc3e45e71f63c729c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a BDD for a largest cube of f.  <a href="#a0b6c71713bfc3fc3e45e71f63c729c4d">More...</a><br /></td></tr>
<tr class="separator:a0b6c71713bfc3fc3e45e71f63c729c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c31130d52ff1e86fbf90aa725cd95b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a68c31130d52ff1e86fbf90aa725cd95b">ddBddMaximallyExpand</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *lb, <a class="el" href="structDdNode.html">DdNode</a> *ub, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a68c31130d52ff1e86fbf90aa725cd95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_bddMaximallyExpand.  <a href="#a68c31130d52ff1e86fbf90aa725cd95b">More...</a><br /></td></tr>
<tr class="separator:a68c31130d52ff1e86fbf90aa725cd95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c44cbf963f2d7b8989c1fbe85c37d0b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a9c44cbf963f2d7b8989c1fbe85c37d0b">ddBddShortestPathUnate</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int *phases, <a class="el" href="structst__table.html">st_table</a> *table)</td></tr>
<tr class="memdesc:a9c44cbf963f2d7b8989c1fbe85c37d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs shortest path computation on a unate function.  <a href="#a9c44cbf963f2d7b8989c1fbe85c37d0b">More...</a><br /></td></tr>
<tr class="separator:a9c44cbf963f2d7b8989c1fbe85c37d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4667addc7d0c7fa97bd42c265de96fd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#ac4667addc7d0c7fa97bd42c265de96fd">ddGetLargestCubeUnate</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int *phases, <a class="el" href="structst__table.html">st_table</a> *table)</td></tr>
<tr class="memdesc:ac4667addc7d0c7fa97bd42c265de96fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts largest prime of a unate function.  <a href="#ac4667addc7d0c7fa97bd42c265de96fd">More...</a><br /></td></tr>
<tr class="separator:ac4667addc7d0c7fa97bd42c265de96fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions for the solution of satisfiability related problems. </p>
<dl class="section author"><dt>Author</dt><dd>Seh-Woong Jeong, Fabio Somenzi</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd><p class="startdd">Copyright (c) 1995-2015, Regents of the University of Colorado</p>
<p class="interdd">All rights reserved.</p>
<p class="interdd">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p class="interdd">Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p class="interdd">Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p class="interdd">Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p class="enddd">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a3a45afd92abdea6f969399e7c0eb5c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a45afd92abdea6f969399e7c0eb5c8f">&#9670;&nbsp;</a></span>Cudd_bddLargestPrimeUnate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddLargestPrimeUnate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>phaseBdd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a largest prime implicant of a unate function. </p>
<p>The behavior is undefined if f is not unate. The third argument is used to determine whether f is unate positive (increasing) or negative (decreasing) in each of the variables in its support.</p>
<dl class="section return"><dt>Returns</dt><dd>the BDD for the prime if succesful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#accb9bb89f75fe6176be961c73a19be09" title="Expands lb to prime implicants of (f and ub).">Cudd_bddMaximallyExpand</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>unate function </td></tr>
    <tr><td class="paramname">phaseBdd</td><td>cube of the phases </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dcbf450b32f6937bc6dba252474638d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dcbf450b32f6937bc6dba252474638d">&#9670;&nbsp;</a></span>Cudd_bddLeqUnless()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddLeqUnless </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether f is less than of equal to G unless D is 1. </p>
<p>f, g, and D are BDDs. No new nodes are created.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if f is less than of equal to G, and 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#a3e078600dd9087c623e1bdfea00d599d" title="Tells whether F and G are identical wherever D is 0.">Cudd_EquivDC</a> <a class="el" href="cuddBddIte_8c.html#a89a46089e8572876a1521cdee6cb31a2" title="Checks whether f is less than or equal to g.">Cudd_bddLeq</a> <a class="el" href="cuddBddIte_8c.html#ae893c6ab0472d7058bd424d02bc9420f" title="Implements ITEconstant(f,g,h).">Cudd_bddIteConstant</a> </dd></dl>

</div>
</div>
<a id="a7b924211354f5d356009a7c804be2340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b924211354f5d356009a7c804be2340">&#9670;&nbsp;</a></span>Cudd_bddMakePrime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddMakePrime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expands cube to a prime implicant of f. </p>
<dl class="section return"><dt>Returns</dt><dd>the prime if successful; NULL otherwise. In particular, NULL is returned if cube is not a real cube or is not an implicant of f.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#accb9bb89f75fe6176be961c73a19be09" title="Expands lb to prime implicants of (f and ub).">Cudd_bddMaximallyExpand</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">cube</td><td>cube to be expanded </td></tr>
    <tr><td class="paramname">f</td><td>function of which the cube is to be made a prime </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accb9bb89f75fe6176be961c73a19be09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb9bb89f75fe6176be961c73a19be09">&#9670;&nbsp;</a></span>Cudd_bddMaximallyExpand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddMaximallyExpand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expands lb to prime implicants of (f and ub). </p>
<p>Expands lb to all prime implicants of (f and ub) that contain lb. Assumes that lb is contained in ub.</p>
<dl class="section return"><dt>Returns</dt><dd>the disjunction of the primes if lb is contained in f; returns the zero BDD if lb is not contained in f; returns NULL in case of failure. In particular, NULL is returned if cube is not a real cube or is not an implicant of f. Returning the disjunction of all prime implicants works because the resulting function is unate.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#a7b924211354f5d356009a7c804be2340" title="Expands cube to a prime implicant of f.">Cudd_bddMakePrime</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">lb</td><td>cube to be expanded </td></tr>
    <tr><td class="paramname">ub</td><td>upper bound cube </td></tr>
    <tr><td class="paramname">f</td><td>function against which to expand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66a70b011fca8b95fbc3953e8b1be1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a70b011fca8b95fbc3953e8b1be1fe">&#9670;&nbsp;</a></span>Cudd_Decreasing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_Decreasing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a BDD is negative unate in a variable. </p>
<p>Determines whether the function represented by BDD f is negative unate (monotonic decreasing) in variable i. This function does not generate any new nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>the constant one is f is unate and the (logical) constant zero if it is not.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#a4f87b23df844d48727ee53f75d868be6" title="Checks whether a BDD is positive unate in a variable.">Cudd_Increasing</a> </dd></dl>

</div>
</div>
<a id="abe0be57ead326db49e00a51d7acf75f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0be57ead326db49e00a51d7acf75f9">&#9670;&nbsp;</a></span>Cudd_EqualSupNorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_EqualSupNorm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two ADDs for equality within tolerance. </p>
<p>Two ADDs are reported to be equal if the maximum difference between them (the sup norm of their difference) is less than or equal to the tolerance parameter. If parameter <code>pr</code> is positive the first failure is reported to the standard output.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the two ADDs are equal (within tolerance); 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first ADD </td></tr>
    <tr><td class="paramname">g</td><td>second ADD </td></tr>
    <tr><td class="paramname">tolerance</td><td>maximum allowed difference </td></tr>
    <tr><td class="paramname">pr</td><td>verbosity level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e078600dd9087c623e1bdfea00d599d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e078600dd9087c623e1bdfea00d599d">&#9670;&nbsp;</a></span>Cudd_EquivDC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_EquivDC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether F and G are identical wherever D is 0. </p>
<p>F and G are either two ADDs or two BDDs. D is either a 0-1 ADD or a BDD. No new nodes are created.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if F and G are equivalent, and 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#a5dcbf450b32f6937bc6dba252474638d" title="Tells whether f is less than of equal to G unless D is 1.">Cudd_bddLeqUnless</a> </dd></dl>

</div>
</div>
<a id="a0f11262fedecf0c0f4376432b478e6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f11262fedecf0c0f4376432b478e6e8">&#9670;&nbsp;</a></span>Cudd_Eval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_Eval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>inputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of a DD for a given variable assignment. </p>
<p>The variable assignment is passed in an array of int's, that should specify a zero or a one for each variable in the support of the function.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a constant node. No new nodes are produced.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddIte_8c.html#a89a46089e8572876a1521cdee6cb31a2" title="Checks whether f is less than or equal to g.">Cudd_bddLeq</a> <a class="el" href="cuddAddIte_8c.html#a88cac595be91f0524a8be01c2b330661" title="Checks whether ADD g is constant whenever ADD f is 1.">Cudd_addEvalConst</a> </dd></dl>

</div>
</div>
<a id="a4f87b23df844d48727ee53f75d868be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f87b23df844d48727ee53f75d868be6">&#9670;&nbsp;</a></span>Cudd_Increasing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_Increasing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a BDD is positive unate in a variable. </p>
<p>Determines whether the function represented by BDD f is positive unate (monotonic increasing) in variable i. It is based on Cudd_Decreasing and the fact that f is monotonic increasing in i if and only if its complement is monotonic decreasing in i.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#a66a70b011fca8b95fbc3953e8b1be1fe" title="Checks whether a BDD is negative unate in a variable.">Cudd_Decreasing</a> </dd></dl>

</div>
</div>
<a id="a5722a5bf76d99cd30783ad87ba03bf96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5722a5bf76d99cd30783ad87ba03bf96">&#9670;&nbsp;</a></span>Cudd_LargestCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_LargestCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a largest cube in a DD. </p>
<p>f is the DD we want to get the largest cube for. The problem is translated into the one of finding a shortest path in f, when both THEN and ELSE arcs are assumed to have unit length. This yields a largest cube in the disjoint cover corresponding to the DD. Therefore, it is not necessarily the largest implicant of f.</p>
<dl class="section return"><dt>Returns</dt><dd>the largest cube as a BDD.</dd></dl>
<dl class="section user"><dt>Side effects\n The number of literals of the cube is returned in the location</dt><dd>pointed by length if it is non-null.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#a78e2d36d1fdfa3d917ad345867bd4596" title="Finds a shortest path in a DD.">Cudd_ShortestPath</a> </dd></dl>

</div>
</div>
<a id="addfc0e508dfd1d0bd0c74104a3dd15e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfc0e508dfd1d0bd0c74104a3dd15e8">&#9670;&nbsp;</a></span>Cudd_ShortestLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ShortestLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the length of the shortest path(s) in a DD. </p>
<p>f is the DD we want to get the shortest path for; weight[i] is the weight of the THEN edge coming from the node whose index is i. All ELSE edges have 0 weight.</p>
<dl class="section return"><dt>Returns</dt><dd>the length of the shortest path(s) if such a path is found; a large number if the function is identically 0, and CUDD_OUT_OF_MEM in case of failure.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#a78e2d36d1fdfa3d917ad345867bd4596" title="Finds a shortest path in a DD.">Cudd_ShortestPath</a> </dd></dl>

</div>
</div>
<a id="a78e2d36d1fdfa3d917ad345867bd4596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e2d36d1fdfa3d917ad345867bd4596">&#9670;&nbsp;</a></span>Cudd_ShortestPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ShortestPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a shortest path in a DD. </p>
<p>f is the DD we want to get the shortest path for; weight[i] is the weight of the THEN arc coming from the node whose index is i. If weight is NULL, then unit weights are assumed for all THEN arcs. All ELSE arcs have 0 weight. If non-NULL, both weight and support should point to arrays with at least as many entries as there are variables in the manager.</p>
<dl class="section return"><dt>Returns</dt><dd>the shortest path as the BDD of a cube.</dd></dl>
<dl class="section user"><dt>Side effects\n support contains on return the true support of f.</dt><dd>If support is NULL on entry, then Cudd_ShortestPath does not compute the true support info. length contains the length of the path.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#addfc0e508dfd1d0bd0c74104a3dd15e8" title="Find the length of the shortest path(s) in a DD.">Cudd_ShortestLength</a> <a class="el" href="cuddSat_8c.html#a5722a5bf76d99cd30783ad87ba03bf96" title="Finds a largest cube in a DD.">Cudd_LargestCube</a> </dd></dl>

</div>
</div>
<a id="aad1ef5892f9b1b85a2766956fca9761c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1ef5892f9b1b85a2766956fca9761c">&#9670;&nbsp;</a></span>cuddBddMakePrime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddBddMakePrime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_bddMakePrime. </p>
<dl class="section return"><dt>Returns</dt><dd>the prime if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">cube</td><td>cube to be expanded </td></tr>
    <tr><td class="paramname">f</td><td>function of which the cube is to be made a prime </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68c31130d52ff1e86fbf90aa725cd95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c31130d52ff1e86fbf90aa725cd95b">&#9670;&nbsp;</a></span>ddBddMaximallyExpand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* ddBddMaximallyExpand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_bddMaximallyExpand. </p>
<p>On entry to this function, ub and lb should be different from the zero BDD. The function then maintains this invariant.</p>
<dl class="section return"><dt>Returns</dt><dd>set of primes or zero BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<p>There are three major terminal cases in theory: ub -&gt; f : return ub lb == f : return lb not(lb -&gt; f): return zero Only the second case can be checked exactly in constant time. For the others, we check for sufficient conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">lb</td><td>cube to be expanded </td></tr>
    <tr><td class="paramname">ub</td><td>upper bound cube </td></tr>
    <tr><td class="paramname">f</td><td>function against which to expand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c44cbf963f2d7b8989c1fbe85c37d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c44cbf963f2d7b8989c1fbe85c37d0b">&#9670;&nbsp;</a></span>ddBddShortestPathUnate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int ddBddShortestPathUnate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>phases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs shortest path computation on a unate function. </p>
<p>This function is based on the observation that in the BDD of a unate function no node except the constant is reachable from the root via paths of different parity.</p>
<dl class="section return"><dt>Returns</dt><dd>the length of the shortest path to one if successful; CUDD_OUT_OF_MEM otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#a3efd005d08ed4ed56179d0f0970bb2e7" title="Finds the length of the shortest path(s) in a DD.">getShortest</a> </dd></dl>

</div>
</div>
<a id="ac4667addc7d0c7fa97bd42c265de96fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4667addc7d0c7fa97bd42c265de96fd">&#9670;&nbsp;</a></span>ddGetLargestCubeUnate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* ddGetLargestCubeUnate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>phases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts largest prime of a unate function. </p>
<dl class="section return"><dt>Returns</dt><dd>the BDD of the prime if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#aa9238a0ffa82b4ae18aec7a04ddcca24" title="Build a BDD for a shortest path of f.">getPath</a> </dd></dl>

</div>
</div>
<a id="a93e5bbe63d2e2598f123244b9789a731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e5bbe63d2e2598f123244b9789a731">&#9670;&nbsp;</a></span>freePathPair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static enum <a class="el" href="st_8h.html#a0c6a172fd99de7928916e65034ed8b1f">st_retval</a> freePathPair </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the entries of the visited symbol table. </p>
<dl class="section return"><dt>Returns</dt><dd>ST_CONTINUE.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a0b6c71713bfc3fc3e45e71f63c729c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6c71713bfc3fc3e45e71f63c729c4d">&#9670;&nbsp;</a></span>getCube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* getCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a BDD for a largest cube of f. </p>
<p>Given the minimum length from the root, and the minimum lengths for each node (in visited), apply triangulation at each node. Of the two children of each node on a shortest path, at least one is on a shortest path. In case of ties the procedure chooses the THEN children.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the cube BDD representing the path if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a8c6ca667c717978d9377526b5466bb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6ca667c717978d9377526b5466bb24">&#9670;&nbsp;</a></span>getLargest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structcuddPathPair.html">cuddPathPair</a> getLargest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the size of the largest cube(s) in a DD. </p>
<p>This problem is translated into finding the shortest paths from a node when both THEN and ELSE arcs have unit lengths. Uses a local symbol table to store the lengths for each node. Only the lengths for the regular nodes are entered in the table, because those for the complement nodes are simply obtained by swapping the two lenghts.</p>
<dl class="section return"><dt>Returns</dt><dd>a pair of lengths: the length of the shortest path to 1; and the length of the shortest path to 0. This is done so as to take complement arcs into account.</dd></dl>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>

</div>
</div>
<a id="aa9238a0ffa82b4ae18aec7a04ddcca24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9238a0ffa82b4ae18aec7a04ddcca24">&#9670;&nbsp;</a></span>getPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* getPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a BDD for a shortest path of f. </p>
<p>Given the minimum length from the root, and the minimum lengths for each node (in visited), apply triangulation at each node. Of the two children of each node on a shortest path, at least one is on a shortest path. In case of ties the procedure chooses the THEN children.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the cube BDD representing the path if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a3efd005d08ed4ed56179d0f0970bb2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3efd005d08ed4ed56179d0f0970bb2e7">&#9670;&nbsp;</a></span>getShortest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structcuddPathPair.html">cuddPathPair</a> getShortest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the length of the shortest path(s) in a DD. </p>
<p>Uses a local symbol table to store the lengths for each node. Only the lengths for the regular nodes are entered in the table, because those for the complement nodes are simply obtained by swapping the two lenghts.</p>
<dl class="section return"><dt>Returns</dt><dd>a pair of lengths: the length of the shortest path to 1; and the length of the shortest path to 0. This is done so as to take complement arcs into account.</dd></dl>
<dl class="section user"><dt>Side effects\n Accumulates the support of the DD in support.</dt><dd></dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 2 2019 17:00:50 for cudd by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>

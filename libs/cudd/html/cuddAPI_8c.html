<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cudd: cudd/cuddAPI.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cudd
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">The University of Colorado Decision Diagram Package</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_3b2091e045759846649695fb574cbfc8.html">cudd</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cuddAPI.c File Reference<div class="ingroups"><a class="el" href="group__cudd.html">cudd</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Application interface functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="util_8h_source.html">util.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mtrInt_8h_source.html">mtrInt.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cuddInt_8h_source.html">cuddInt.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for cuddAPI.c:</div>
<div class="dyncontent">
<div class="center"><img src="cuddAPI_8c__incl.png" border="0" usemap="#cudd_2cuddAPI_8c" alt=""/></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad77f4dd2911bac8e25633fe84c6cfb8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ad77f4dd2911bac8e25633fe84c6cfb8b">Cudd_addNewVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ad77f4dd2911bac8e25633fe84c6cfb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new ADD variable.  <a href="#ad77f4dd2911bac8e25633fe84c6cfb8b">More...</a><br /></td></tr>
<tr class="separator:ad77f4dd2911bac8e25633fe84c6cfb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacea7b5ed8dc2595a1c0e01788bc205a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#aacea7b5ed8dc2595a1c0e01788bc205a">Cudd_addNewVarAtLevel</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int level)</td></tr>
<tr class="memdesc:aacea7b5ed8dc2595a1c0e01788bc205a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new ADD variable at a specified level.  <a href="#aacea7b5ed8dc2595a1c0e01788bc205a">More...</a><br /></td></tr>
<tr class="separator:aacea7b5ed8dc2595a1c0e01788bc205a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475c50e1a273569cc0ffc19ab98c28ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a475c50e1a273569cc0ffc19ab98c28ce">Cudd_bddNewVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a475c50e1a273569cc0ffc19ab98c28ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new BDD variable.  <a href="#a475c50e1a273569cc0ffc19ab98c28ce">More...</a><br /></td></tr>
<tr class="separator:a475c50e1a273569cc0ffc19ab98c28ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35eac7df807101795efe0d582ff05fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ae35eac7df807101795efe0d582ff05fa">Cudd_bddNewVarAtLevel</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int level)</td></tr>
<tr class="memdesc:ae35eac7df807101795efe0d582ff05fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new BDD variable at a specified level.  <a href="#ae35eac7df807101795efe0d582ff05fa">More...</a><br /></td></tr>
<tr class="separator:ae35eac7df807101795efe0d582ff05fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7174f24036c4eae624311b273df978da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a7174f24036c4eae624311b273df978da">Cudd_bddIsVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a7174f24036c4eae624311b273df978da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the given node is a BDD variable; 0 otherwise.  <a href="#a7174f24036c4eae624311b273df978da">More...</a><br /></td></tr>
<tr class="separator:a7174f24036c4eae624311b273df978da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19967d7c87650f63fc312f38c318e3e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a19967d7c87650f63fc312f38c318e3e9">Cudd_addIthVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int i)</td></tr>
<tr class="memdesc:a19967d7c87650f63fc312f38c318e3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ADD variable with index i.  <a href="#a19967d7c87650f63fc312f38c318e3e9">More...</a><br /></td></tr>
<tr class="separator:a19967d7c87650f63fc312f38c318e3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fd71665cde402bd5bc4f39015c09ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a40fd71665cde402bd5bc4f39015c09ae">Cudd_bddIthVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int i)</td></tr>
<tr class="memdesc:a40fd71665cde402bd5bc4f39015c09ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the BDD variable with index i.  <a href="#a40fd71665cde402bd5bc4f39015c09ae">More...</a><br /></td></tr>
<tr class="separator:a40fd71665cde402bd5bc4f39015c09ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf8017813ae9a60790ae4f8a445800d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#acbf8017813ae9a60790ae4f8a445800d">Cudd_zddIthVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int i)</td></tr>
<tr class="memdesc:acbf8017813ae9a60790ae4f8a445800d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ZDD variable with index i.  <a href="#acbf8017813ae9a60790ae4f8a445800d">More...</a><br /></td></tr>
<tr class="separator:acbf8017813ae9a60790ae4f8a445800d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d898e3087539ceaaf5ff86aa62c471"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a45d898e3087539ceaaf5ff86aa62c471">Cudd_zddVarsFromBddVars</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int multiplicity)</td></tr>
<tr class="memdesc:a45d898e3087539ceaaf5ff86aa62c471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates one or more ZDD variables for each BDD variable.  <a href="#a45d898e3087539ceaaf5ff86aa62c471">More...</a><br /></td></tr>
<tr class="separator:a45d898e3087539ceaaf5ff86aa62c471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbe3503e24e823a81bc2c8acb065345"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a1dbe3503e24e823a81bc2c8acb065345">Cudd_ReadMaxIndex</a> (void)</td></tr>
<tr class="memdesc:a1dbe3503e24e823a81bc2c8acb065345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum possible index for a variable.  <a href="#a1dbe3503e24e823a81bc2c8acb065345">More...</a><br /></td></tr>
<tr class="separator:a1dbe3503e24e823a81bc2c8acb065345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8fb347b6c5324ef9bce64aa73a63bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a8b8fb347b6c5324ef9bce64aa73a63bb">Cudd_addConst</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> c)</td></tr>
<tr class="memdesc:a8b8fb347b6c5324ef9bce64aa73a63bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ADD for constant c.  <a href="#a8b8fb347b6c5324ef9bce64aa73a63bb">More...</a><br /></td></tr>
<tr class="separator:a8b8fb347b6c5324ef9bce64aa73a63bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018bdc54a42aacf14959f83cbf6992b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a018bdc54a42aacf14959f83cbf6992b6">Cudd_IsConstant</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a018bdc54a42aacf14959f83cbf6992b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the node is a constant node.  <a href="#a018bdc54a42aacf14959f83cbf6992b6">More...</a><br /></td></tr>
<tr class="separator:a018bdc54a42aacf14959f83cbf6992b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac0cf7ba2eba7a6652a886deb4723fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a4ac0cf7ba2eba7a6652a886deb4723fa">Cudd_IsNonConstant</a> (<a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a4ac0cf7ba2eba7a6652a886deb4723fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if a DD node is not constant.  <a href="#a4ac0cf7ba2eba7a6652a886deb4723fa">More...</a><br /></td></tr>
<tr class="separator:a4ac0cf7ba2eba7a6652a886deb4723fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed52f5319f877acc6ac7c27490111b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#aeed52f5319f877acc6ac7c27490111b6">Cudd_T</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:aeed52f5319f877acc6ac7c27490111b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the then child of an internal node.  <a href="#aeed52f5319f877acc6ac7c27490111b6">More...</a><br /></td></tr>
<tr class="separator:aeed52f5319f877acc6ac7c27490111b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601a736699b3e5c8eb7149e6049ea131"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a601a736699b3e5c8eb7149e6049ea131">Cudd_E</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a601a736699b3e5c8eb7149e6049ea131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the else child of an internal node.  <a href="#a601a736699b3e5c8eb7149e6049ea131">More...</a><br /></td></tr>
<tr class="separator:a601a736699b3e5c8eb7149e6049ea131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebe62ac5ac8a49dc13bce839ae09c88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a9ebe62ac5ac8a49dc13bce839ae09c88">Cudd_V</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a9ebe62ac5ac8a49dc13bce839ae09c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a constant node.  <a href="#a9ebe62ac5ac8a49dc13bce839ae09c88">More...</a><br /></td></tr>
<tr class="separator:a9ebe62ac5ac8a49dc13bce839ae09c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94781bf6e62d0c6a3439b4db11b50e5"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ae94781bf6e62d0c6a3439b4db11b50e5">Cudd_ReadStartTime</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:ae94781bf6e62d0c6a3439b4db11b50e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the start time of the manager.  <a href="#ae94781bf6e62d0c6a3439b4db11b50e5">More...</a><br /></td></tr>
<tr class="separator:ae94781bf6e62d0c6a3439b4db11b50e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cafb71c46dedb3eaa27acd56b855b8"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ab6cafb71c46dedb3eaa27acd56b855b8">Cudd_ReadElapsedTime</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:ab6cafb71c46dedb3eaa27acd56b855b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time elapsed since the start time of the manager.  <a href="#ab6cafb71c46dedb3eaa27acd56b855b8">More...</a><br /></td></tr>
<tr class="separator:ab6cafb71c46dedb3eaa27acd56b855b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b42ab1fa12990140dbfd415bc7a6231"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a2b42ab1fa12990140dbfd415bc7a6231">Cudd_SetStartTime</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, unsigned long st)</td></tr>
<tr class="memdesc:a2b42ab1fa12990140dbfd415bc7a6231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the start time of the manager.  <a href="#a2b42ab1fa12990140dbfd415bc7a6231">More...</a><br /></td></tr>
<tr class="separator:a2b42ab1fa12990140dbfd415bc7a6231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bbaa787eb4bbf866292ea6f566e427"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ac8bbaa787eb4bbf866292ea6f566e427">Cudd_ResetStartTime</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:ac8bbaa787eb4bbf866292ea6f566e427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the start time of the manager.  <a href="#ac8bbaa787eb4bbf866292ea6f566e427">More...</a><br /></td></tr>
<tr class="separator:ac8bbaa787eb4bbf866292ea6f566e427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855a253235b54ff16fd66c6e43241069"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a855a253235b54ff16fd66c6e43241069">Cudd_ReadTimeLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a855a253235b54ff16fd66c6e43241069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time limit for the manager.  <a href="#a855a253235b54ff16fd66c6e43241069">More...</a><br /></td></tr>
<tr class="separator:a855a253235b54ff16fd66c6e43241069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e694e133632d34256646869f076ff5"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ac6e694e133632d34256646869f076ff5">Cudd_SetTimeLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, unsigned long tl)</td></tr>
<tr class="memdesc:ac6e694e133632d34256646869f076ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the time limit for the manager.  <a href="#ac6e694e133632d34256646869f076ff5">More...</a><br /></td></tr>
<tr class="separator:ac6e694e133632d34256646869f076ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb6240810097270fd1414536de17eb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#aeeb6240810097270fd1414536de17eb0">Cudd_UpdateTimeLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:aeeb6240810097270fd1414536de17eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the time limit for the manager.  <a href="#aeeb6240810097270fd1414536de17eb0">More...</a><br /></td></tr>
<tr class="separator:aeeb6240810097270fd1414536de17eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333169d352f3ab54002eaae738a39d68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a333169d352f3ab54002eaae738a39d68">Cudd_IncreaseTimeLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, unsigned long increase)</td></tr>
<tr class="memdesc:a333169d352f3ab54002eaae738a39d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the time limit for the manager.  <a href="#a333169d352f3ab54002eaae738a39d68">More...</a><br /></td></tr>
<tr class="separator:a333169d352f3ab54002eaae738a39d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa497c8cb498833021f18813fb5813b57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#aa497c8cb498833021f18813fb5813b57">Cudd_UnsetTimeLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:aa497c8cb498833021f18813fb5813b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the time limit for the manager.  <a href="#aa497c8cb498833021f18813fb5813b57">More...</a><br /></td></tr>
<tr class="separator:aa497c8cb498833021f18813fb5813b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3b2370790803f37aace1dfc0a7d1cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a7c3b2370790803f37aace1dfc0a7d1cc">Cudd_TimeLimited</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a7c3b2370790803f37aace1dfc0a7d1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the time limit for the manager is set.  <a href="#a7c3b2370790803f37aace1dfc0a7d1cc">More...</a><br /></td></tr>
<tr class="separator:a7c3b2370790803f37aace1dfc0a7d1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbdd1ef4d92a8f7d60304e2cc17ff6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a5dbdd1ef4d92a8f7d60304e2cc17ff6e">Cudd_RegisterTerminationCallback</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, <a class="el" href="cudd_8h.html#ab19edd4d89e40f721e04dbdeb3e36684">DD_THFP</a> callback, void *callback_arg)</td></tr>
<tr class="memdesc:a5dbdd1ef4d92a8f7d60304e2cc17ff6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a termination callback.  <a href="#a5dbdd1ef4d92a8f7d60304e2cc17ff6e">More...</a><br /></td></tr>
<tr class="separator:a5dbdd1ef4d92a8f7d60304e2cc17ff6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8014219cc6794497d58c3eeb140db8c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a8014219cc6794497d58c3eeb140db8c8">Cudd_UnregisterTerminationCallback</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a8014219cc6794497d58c3eeb140db8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a termination callback.  <a href="#a8014219cc6794497d58c3eeb140db8c8">More...</a><br /></td></tr>
<tr class="separator:a8014219cc6794497d58c3eeb140db8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa76d8075f1af649c8741af26369836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#ab7b4676c7e2dd36567b3749740ca8b60">DD_OOMFP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a6aa76d8075f1af649c8741af26369836">Cudd_RegisterOutOfMemoryCallback</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, <a class="el" href="cudd_8h.html#ab7b4676c7e2dd36567b3749740ca8b60">DD_OOMFP</a> callback)</td></tr>
<tr class="memdesc:a6aa76d8075f1af649c8741af26369836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs an out-of-memory callback.  <a href="#a6aa76d8075f1af649c8741af26369836">More...</a><br /></td></tr>
<tr class="separator:a6aa76d8075f1af649c8741af26369836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6966d8f04f26fd49495f3703a771ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a1b6966d8f04f26fd49495f3703a771ce">Cudd_UnregisterOutOfMemoryCallback</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a1b6966d8f04f26fd49495f3703a771ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister an out-of-memory callback.  <a href="#a1b6966d8f04f26fd49495f3703a771ce">More...</a><br /></td></tr>
<tr class="separator:a1b6966d8f04f26fd49495f3703a771ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122a5e97bfebdc0362991d1caaa96115"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a122a5e97bfebdc0362991d1caaa96115">Cudd_RegisterTimeoutHandler</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, <a class="el" href="cudd_8h.html#a55dd2f7df5ab2f9df7e9e5c969adc0aa">DD_TOHFP</a> handler, void *arg)</td></tr>
<tr class="memdesc:a122a5e97bfebdc0362991d1caaa96115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a timeout handler function.  <a href="#a122a5e97bfebdc0362991d1caaa96115">More...</a><br /></td></tr>
<tr class="separator:a122a5e97bfebdc0362991d1caaa96115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1312ca893e36e0b628804b12e5df32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#a55dd2f7df5ab2f9df7e9e5c969adc0aa">DD_TOHFP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a4b1312ca893e36e0b628804b12e5df32">Cudd_ReadTimeoutHandler</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, void **argp)</td></tr>
<tr class="memdesc:a4b1312ca893e36e0b628804b12e5df32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current timeout handler function.  <a href="#a4b1312ca893e36e0b628804b12e5df32">More...</a><br /></td></tr>
<tr class="separator:a4b1312ca893e36e0b628804b12e5df32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0d69b4288f36d5d377c460d49066a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a6a0d69b4288f36d5d377c460d49066a6">Cudd_AutodynEnable</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, <a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a> method)</td></tr>
<tr class="memdesc:a6a0d69b4288f36d5d377c460d49066a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables automatic dynamic reordering of BDDs and ADDs.  <a href="#a6a0d69b4288f36d5d377c460d49066a6">More...</a><br /></td></tr>
<tr class="separator:a6a0d69b4288f36d5d377c460d49066a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd2c1c2a110944c1d760de577aed431"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#affd2c1c2a110944c1d760de577aed431">Cudd_AutodynDisable</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:affd2c1c2a110944c1d760de577aed431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables automatic dynamic reordering.  <a href="#affd2c1c2a110944c1d760de577aed431">More...</a><br /></td></tr>
<tr class="separator:affd2c1c2a110944c1d760de577aed431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3806c2327487b3cea3c7ffff75aead83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a3806c2327487b3cea3c7ffff75aead83">Cudd_ReorderingStatus</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, <a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a> *method)</td></tr>
<tr class="memdesc:a3806c2327487b3cea3c7ffff75aead83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the status of automatic dynamic reordering of BDDs and ADDs.  <a href="#a3806c2327487b3cea3c7ffff75aead83">More...</a><br /></td></tr>
<tr class="separator:a3806c2327487b3cea3c7ffff75aead83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709e0e15a38d6d6e9c83ff8b8a9d07f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a709e0e15a38d6d6e9c83ff8b8a9d07f2">Cudd_AutodynEnableZdd</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, <a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a> method)</td></tr>
<tr class="memdesc:a709e0e15a38d6d6e9c83ff8b8a9d07f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables automatic dynamic reordering of ZDDs.  <a href="#a709e0e15a38d6d6e9c83ff8b8a9d07f2">More...</a><br /></td></tr>
<tr class="separator:a709e0e15a38d6d6e9c83ff8b8a9d07f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219ccb201e3c1aa25ebef007399849fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a219ccb201e3c1aa25ebef007399849fa">Cudd_AutodynDisableZdd</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a219ccb201e3c1aa25ebef007399849fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables automatic dynamic reordering of ZDDs.  <a href="#a219ccb201e3c1aa25ebef007399849fa">More...</a><br /></td></tr>
<tr class="separator:a219ccb201e3c1aa25ebef007399849fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f65c44244489bfbb37137929baf0cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ac6f65c44244489bfbb37137929baf0cd">Cudd_ReorderingStatusZdd</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, <a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a> *method)</td></tr>
<tr class="memdesc:ac6f65c44244489bfbb37137929baf0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the status of automatic dynamic reordering of ZDDs.  <a href="#ac6f65c44244489bfbb37137929baf0cd">More...</a><br /></td></tr>
<tr class="separator:ac6f65c44244489bfbb37137929baf0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34225975eef55170213a0a9efed5a891"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a34225975eef55170213a0a9efed5a891">Cudd_zddRealignmentEnabled</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a34225975eef55170213a0a9efed5a891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether the realignment of ZDD order to BDD order is enabled.  <a href="#a34225975eef55170213a0a9efed5a891">More...</a><br /></td></tr>
<tr class="separator:a34225975eef55170213a0a9efed5a891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57aff1886a1fea0cb8b5bf8d66cf50e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#aa57aff1886a1fea0cb8b5bf8d66cf50e">Cudd_zddRealignEnable</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:aa57aff1886a1fea0cb8b5bf8d66cf50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables realignment of ZDD order to BDD order.  <a href="#aa57aff1886a1fea0cb8b5bf8d66cf50e">More...</a><br /></td></tr>
<tr class="separator:aa57aff1886a1fea0cb8b5bf8d66cf50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea01466660ca226539a66a014a4da00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#afea01466660ca226539a66a014a4da00">Cudd_zddRealignDisable</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:afea01466660ca226539a66a014a4da00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables realignment of ZDD order to BDD order.  <a href="#afea01466660ca226539a66a014a4da00">More...</a><br /></td></tr>
<tr class="separator:afea01466660ca226539a66a014a4da00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516183604a75b38337b81fd17c291826"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a516183604a75b38337b81fd17c291826">Cudd_bddRealignmentEnabled</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a516183604a75b38337b81fd17c291826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether the realignment of BDD order to ZDD order is enabled.  <a href="#a516183604a75b38337b81fd17c291826">More...</a><br /></td></tr>
<tr class="separator:a516183604a75b38337b81fd17c291826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0d34d836668fc62e7c7835fa95132d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a2d0d34d836668fc62e7c7835fa95132d">Cudd_bddRealignEnable</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a2d0d34d836668fc62e7c7835fa95132d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables realignment of BDD order to ZDD order.  <a href="#a2d0d34d836668fc62e7c7835fa95132d">More...</a><br /></td></tr>
<tr class="separator:a2d0d34d836668fc62e7c7835fa95132d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb093bdd80db0b880f61017f3e36de2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a3eb093bdd80db0b880f61017f3e36de2">Cudd_bddRealignDisable</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a3eb093bdd80db0b880f61017f3e36de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables realignment of ZDD order to BDD order.  <a href="#a3eb093bdd80db0b880f61017f3e36de2">More...</a><br /></td></tr>
<tr class="separator:a3eb093bdd80db0b880f61017f3e36de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2651c953d81570d3f4f794bcbef40afe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a2651c953d81570d3f4f794bcbef40afe">Cudd_ReadOne</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a2651c953d81570d3f4f794bcbef40afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the one constant of the manager.  <a href="#a2651c953d81570d3f4f794bcbef40afe">More...</a><br /></td></tr>
<tr class="separator:a2651c953d81570d3f4f794bcbef40afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d6950021b06a3bf4a6bcd05b1753e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ad6d6950021b06a3bf4a6bcd05b1753e7">Cudd_ReadZddOne</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int i)</td></tr>
<tr class="memdesc:ad6d6950021b06a3bf4a6bcd05b1753e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ZDD for the constant 1 function.  <a href="#ad6d6950021b06a3bf4a6bcd05b1753e7">More...</a><br /></td></tr>
<tr class="separator:ad6d6950021b06a3bf4a6bcd05b1753e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92900f3320df460a72eacc4ed801d69e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a92900f3320df460a72eacc4ed801d69e">Cudd_ReadZero</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a92900f3320df460a72eacc4ed801d69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the zero constant of the manager.  <a href="#a92900f3320df460a72eacc4ed801d69e">More...</a><br /></td></tr>
<tr class="separator:a92900f3320df460a72eacc4ed801d69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd42d8cb5c86659170103a3068e13a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a1dd42d8cb5c86659170103a3068e13a6">Cudd_ReadLogicZero</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a1dd42d8cb5c86659170103a3068e13a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logic zero constant of the manager.  <a href="#a1dd42d8cb5c86659170103a3068e13a6">More...</a><br /></td></tr>
<tr class="separator:a1dd42d8cb5c86659170103a3068e13a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af581badbfb76ba5909f83482c47d743e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#af581badbfb76ba5909f83482c47d743e">Cudd_ReadPlusInfinity</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:af581badbfb76ba5909f83482c47d743e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the plus-infinity constant from the manager.  <a href="#af581badbfb76ba5909f83482c47d743e">More...</a><br /></td></tr>
<tr class="separator:af581badbfb76ba5909f83482c47d743e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ff7f850bf0b84af8ea0779ec0800ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ae0ff7f850bf0b84af8ea0779ec0800ac">Cudd_ReadMinusInfinity</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ae0ff7f850bf0b84af8ea0779ec0800ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the minus-infinity constant from the manager.  <a href="#ae0ff7f850bf0b84af8ea0779ec0800ac">More...</a><br /></td></tr>
<tr class="separator:ae0ff7f850bf0b84af8ea0779ec0800ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041d561f9d388a943104665fe0c850c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a041d561f9d388a943104665fe0c850c0">Cudd_ReadBackground</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a041d561f9d388a943104665fe0c850c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the background constant of the manager.  <a href="#a041d561f9d388a943104665fe0c850c0">More...</a><br /></td></tr>
<tr class="separator:a041d561f9d388a943104665fe0c850c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3792749a2a10045b60d2a3d99d99928e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a3792749a2a10045b60d2a3d99d99928e">Cudd_SetBackground</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *bck)</td></tr>
<tr class="memdesc:a3792749a2a10045b60d2a3d99d99928e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the background constant of the manager.  <a href="#a3792749a2a10045b60d2a3d99d99928e">More...</a><br /></td></tr>
<tr class="separator:a3792749a2a10045b60d2a3d99d99928e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab588943f358faadd3c7e8a4caf813fce"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ab588943f358faadd3c7e8a4caf813fce">Cudd_ReadCacheSlots</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ab588943f358faadd3c7e8a4caf813fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the number of slots in the cache.  <a href="#ab588943f358faadd3c7e8a4caf813fce">More...</a><br /></td></tr>
<tr class="separator:ab588943f358faadd3c7e8a4caf813fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac309a335487dbb3ba77b088c90e085c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#aac309a335487dbb3ba77b088c90e085c">Cudd_ReadCacheUsedSlots</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:aac309a335487dbb3ba77b088c90e085c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the fraction of used slots in the cache.  <a href="#aac309a335487dbb3ba77b088c90e085c">More...</a><br /></td></tr>
<tr class="separator:aac309a335487dbb3ba77b088c90e085c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4595bfefe543b3f8f74248c048b53fe"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ab4595bfefe543b3f8f74248c048b53fe">Cudd_ReadCacheLookUps</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ab4595bfefe543b3f8f74248c048b53fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of cache look-ups.  <a href="#ab4595bfefe543b3f8f74248c048b53fe">More...</a><br /></td></tr>
<tr class="separator:ab4595bfefe543b3f8f74248c048b53fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2281582d99df044cf8892204026b64b9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a2281582d99df044cf8892204026b64b9">Cudd_ReadCacheHits</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a2281582d99df044cf8892204026b64b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of cache hits.  <a href="#a2281582d99df044cf8892204026b64b9">More...</a><br /></td></tr>
<tr class="separator:a2281582d99df044cf8892204026b64b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8ec5d88cf36fd80006b157252be029"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a3d8ec5d88cf36fd80006b157252be029">Cudd_ReadRecursiveCalls</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a3d8ec5d88cf36fd80006b157252be029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of recursive calls.  <a href="#a3d8ec5d88cf36fd80006b157252be029">More...</a><br /></td></tr>
<tr class="separator:a3d8ec5d88cf36fd80006b157252be029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79695ef1e6f821d310f5613a6d8ba148"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a79695ef1e6f821d310f5613a6d8ba148">Cudd_ReadMinHit</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a79695ef1e6f821d310f5613a6d8ba148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the hit rate that causes resizinig of the computed table.  <a href="#a79695ef1e6f821d310f5613a6d8ba148">More...</a><br /></td></tr>
<tr class="separator:a79695ef1e6f821d310f5613a6d8ba148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96f3e2036a77ab8c1318e607dea232b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ae96f3e2036a77ab8c1318e607dea232b">Cudd_SetMinHit</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, unsigned int hr)</td></tr>
<tr class="memdesc:ae96f3e2036a77ab8c1318e607dea232b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the hit rate that causes resizinig of the computed table.  <a href="#ae96f3e2036a77ab8c1318e607dea232b">More...</a><br /></td></tr>
<tr class="separator:ae96f3e2036a77ab8c1318e607dea232b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab452b9f1bbcdb8bf49cbea25f6e8ed8d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ab452b9f1bbcdb8bf49cbea25f6e8ed8d">Cudd_ReadLooseUpTo</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ab452b9f1bbcdb8bf49cbea25f6e8ed8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the looseUpTo parameter of the manager.  <a href="#ab452b9f1bbcdb8bf49cbea25f6e8ed8d">More...</a><br /></td></tr>
<tr class="separator:ab452b9f1bbcdb8bf49cbea25f6e8ed8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1952bb97db9782bcf607d169c842b7ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a1952bb97db9782bcf607d169c842b7ce">Cudd_SetLooseUpTo</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, unsigned int lut)</td></tr>
<tr class="memdesc:a1952bb97db9782bcf607d169c842b7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the looseUpTo parameter of the manager.  <a href="#a1952bb97db9782bcf607d169c842b7ce">More...</a><br /></td></tr>
<tr class="separator:a1952bb97db9782bcf607d169c842b7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dafbaafff7055890cce20fa791b2092"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a7dafbaafff7055890cce20fa791b2092">Cudd_ReadMaxCache</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a7dafbaafff7055890cce20fa791b2092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the soft limit for the cache size.  <a href="#a7dafbaafff7055890cce20fa791b2092">More...</a><br /></td></tr>
<tr class="separator:a7dafbaafff7055890cce20fa791b2092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfac0e32bb4bcfe7f0035f4fff401a0e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#acfac0e32bb4bcfe7f0035f4fff401a0e">Cudd_ReadMaxCacheHard</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:acfac0e32bb4bcfe7f0035f4fff401a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the maxCacheHard parameter of the manager.  <a href="#acfac0e32bb4bcfe7f0035f4fff401a0e">More...</a><br /></td></tr>
<tr class="separator:acfac0e32bb4bcfe7f0035f4fff401a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ced83212c4c45f94d8957e3fab485c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a4ced83212c4c45f94d8957e3fab485c5">Cudd_SetMaxCacheHard</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, unsigned int mc)</td></tr>
<tr class="memdesc:a4ced83212c4c45f94d8957e3fab485c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maxCacheHard parameter of the manager.  <a href="#a4ced83212c4c45f94d8957e3fab485c5">More...</a><br /></td></tr>
<tr class="separator:a4ced83212c4c45f94d8957e3fab485c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1647f3f86f4e555bea35673f9539f94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94">Cudd_ReadSize</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ab1647f3f86f4e555bea35673f9539f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of BDD variables in existance.  <a href="#ab1647f3f86f4e555bea35673f9539f94">More...</a><br /></td></tr>
<tr class="separator:ab1647f3f86f4e555bea35673f9539f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a5d45fa3fb62aa72a3aa280c563f9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a82a5d45fa3fb62aa72a3aa280c563f9d">Cudd_ReadZddSize</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a82a5d45fa3fb62aa72a3aa280c563f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of ZDD variables in existance.  <a href="#a82a5d45fa3fb62aa72a3aa280c563f9d">More...</a><br /></td></tr>
<tr class="separator:a82a5d45fa3fb62aa72a3aa280c563f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3787560300153655851b4fe3c7646b0c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a3787560300153655851b4fe3c7646b0c">Cudd_ReadSlots</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a3787560300153655851b4fe3c7646b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of slots of the unique table.  <a href="#a3787560300153655851b4fe3c7646b0c">More...</a><br /></td></tr>
<tr class="separator:a3787560300153655851b4fe3c7646b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0941cb7338ba1a71f3451f4c2a747093"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a0941cb7338ba1a71f3451f4c2a747093">Cudd_ReadUsedSlots</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a0941cb7338ba1a71f3451f4c2a747093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the fraction of used slots in the unique table.  <a href="#a0941cb7338ba1a71f3451f4c2a747093">More...</a><br /></td></tr>
<tr class="separator:a0941cb7338ba1a71f3451f4c2a747093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d06c2608e7c5b08b3fd6c6e200662f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a31d06c2608e7c5b08b3fd6c6e200662f">Cudd_ExpectedUsedSlots</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a31d06c2608e7c5b08b3fd6c6e200662f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the expected fraction of used slots in the unique table.  <a href="#a31d06c2608e7c5b08b3fd6c6e200662f">More...</a><br /></td></tr>
<tr class="separator:a31d06c2608e7c5b08b3fd6c6e200662f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc6805752cf0bc83080322d778759e6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a5bc6805752cf0bc83080322d778759e6">Cudd_ReadKeys</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a5bc6805752cf0bc83080322d778759e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes in the unique table.  <a href="#a5bc6805752cf0bc83080322d778759e6">More...</a><br /></td></tr>
<tr class="separator:a5bc6805752cf0bc83080322d778759e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4074f697e7ea725a1b853d9a468a082e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a4074f697e7ea725a1b853d9a468a082e">Cudd_ReadDead</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a4074f697e7ea725a1b853d9a468a082e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of dead nodes in the unique table.  <a href="#a4074f697e7ea725a1b853d9a468a082e">More...</a><br /></td></tr>
<tr class="separator:a4074f697e7ea725a1b853d9a468a082e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace82092e4e785b388c83f554daa23283"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ace82092e4e785b388c83f554daa23283">Cudd_ReadMinDead</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ace82092e4e785b388c83f554daa23283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the minDead parameter of the manager.  <a href="#ace82092e4e785b388c83f554daa23283">More...</a><br /></td></tr>
<tr class="separator:ace82092e4e785b388c83f554daa23283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22056db7260493748eda0162431cd76"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ac22056db7260493748eda0162431cd76">Cudd_ReadReorderings</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ac22056db7260493748eda0162431cd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times reordering has occurred.  <a href="#ac22056db7260493748eda0162431cd76">More...</a><br /></td></tr>
<tr class="separator:ac22056db7260493748eda0162431cd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad011aad1e779f0e31ab67cf7a1d7f591"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ad011aad1e779f0e31ab67cf7a1d7f591">Cudd_ReadMaxReorderings</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ad011aad1e779f0e31ab67cf7a1d7f591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of times reordering may be invoked.  <a href="#ad011aad1e779f0e31ab67cf7a1d7f591">More...</a><br /></td></tr>
<tr class="separator:ad011aad1e779f0e31ab67cf7a1d7f591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2e39aeebc215847d374a01bb1f182b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a3a2e39aeebc215847d374a01bb1f182b">Cudd_SetMaxReorderings</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, unsigned int mr)</td></tr>
<tr class="memdesc:a3a2e39aeebc215847d374a01bb1f182b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of times reordering may be invoked.  <a href="#a3a2e39aeebc215847d374a01bb1f182b">More...</a><br /></td></tr>
<tr class="separator:a3a2e39aeebc215847d374a01bb1f182b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61141274ba36755e4c88a4c1597b9847"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a61141274ba36755e4c88a4c1597b9847">Cudd_ReadReorderingTime</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a61141274ba36755e4c88a4c1597b9847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time spent in reordering.  <a href="#a61141274ba36755e4c88a4c1597b9847">More...</a><br /></td></tr>
<tr class="separator:a61141274ba36755e4c88a4c1597b9847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aaebdd320041ddca11fdb0f3414f0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a50aaebdd320041ddca11fdb0f3414f0c">Cudd_ReadGarbageCollections</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a50aaebdd320041ddca11fdb0f3414f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times garbage collection has occurred.  <a href="#a50aaebdd320041ddca11fdb0f3414f0c">More...</a><br /></td></tr>
<tr class="separator:a50aaebdd320041ddca11fdb0f3414f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653fa9231b3d68947521175de74f26b8"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a653fa9231b3d68947521175de74f26b8">Cudd_ReadGarbageCollectionTime</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a653fa9231b3d68947521175de74f26b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time spent in garbage collection.  <a href="#a653fa9231b3d68947521175de74f26b8">More...</a><br /></td></tr>
<tr class="separator:a653fa9231b3d68947521175de74f26b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af525911b0006fddcbcf698a077b874cb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#af525911b0006fddcbcf698a077b874cb">Cudd_ReadNodesFreed</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:af525911b0006fddcbcf698a077b874cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes freed.  <a href="#af525911b0006fddcbcf698a077b874cb">More...</a><br /></td></tr>
<tr class="separator:af525911b0006fddcbcf698a077b874cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e283a368a08c5ac96101ee7e9b525c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ae7e283a368a08c5ac96101ee7e9b525c">Cudd_ReadNodesDropped</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ae7e283a368a08c5ac96101ee7e9b525c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes dropped.  <a href="#ae7e283a368a08c5ac96101ee7e9b525c">More...</a><br /></td></tr>
<tr class="separator:ae7e283a368a08c5ac96101ee7e9b525c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebf224e24889082c229d56db1f982f3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#acebf224e24889082c229d56db1f982f3">Cudd_ReadUniqueLookUps</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:acebf224e24889082c229d56db1f982f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of look-ups in the unique table.  <a href="#acebf224e24889082c229d56db1f982f3">More...</a><br /></td></tr>
<tr class="separator:acebf224e24889082c229d56db1f982f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa1d598d1d5830c72b33aca86e511c1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#aaaa1d598d1d5830c72b33aca86e511c1">Cudd_ReadUniqueLinks</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:aaaa1d598d1d5830c72b33aca86e511c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of links followed in the unique table.  <a href="#aaaa1d598d1d5830c72b33aca86e511c1">More...</a><br /></td></tr>
<tr class="separator:aaaa1d598d1d5830c72b33aca86e511c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112841ed78d8f90d31ee879684775b51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a112841ed78d8f90d31ee879684775b51">Cudd_ReadSiftMaxVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a112841ed78d8f90d31ee879684775b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the siftMaxVar parameter of the manager.  <a href="#a112841ed78d8f90d31ee879684775b51">More...</a><br /></td></tr>
<tr class="separator:a112841ed78d8f90d31ee879684775b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ad3e7bf12607f58756e15f2b1251aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a23ad3e7bf12607f58756e15f2b1251aa">Cudd_SetSiftMaxVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int smv)</td></tr>
<tr class="memdesc:a23ad3e7bf12607f58756e15f2b1251aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the siftMaxVar parameter of the manager.  <a href="#a23ad3e7bf12607f58756e15f2b1251aa">More...</a><br /></td></tr>
<tr class="separator:a23ad3e7bf12607f58756e15f2b1251aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fbfd8fa0597af542ad9dfa4eefa2da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a54fbfd8fa0597af542ad9dfa4eefa2da">Cudd_ReadSiftMaxSwap</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a54fbfd8fa0597af542ad9dfa4eefa2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the siftMaxSwap parameter of the manager.  <a href="#a54fbfd8fa0597af542ad9dfa4eefa2da">More...</a><br /></td></tr>
<tr class="separator:a54fbfd8fa0597af542ad9dfa4eefa2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40246082da9de77243088f935be6e2e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a40246082da9de77243088f935be6e2e6">Cudd_SetSiftMaxSwap</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int sms)</td></tr>
<tr class="memdesc:a40246082da9de77243088f935be6e2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the siftMaxSwap parameter of the manager.  <a href="#a40246082da9de77243088f935be6e2e6">More...</a><br /></td></tr>
<tr class="separator:a40246082da9de77243088f935be6e2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f3600540de47d20e85eb4036af6e49"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a23f3600540de47d20e85eb4036af6e49">Cudd_ReadMaxGrowth</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a23f3600540de47d20e85eb4036af6e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the maxGrowth parameter of the manager.  <a href="#a23f3600540de47d20e85eb4036af6e49">More...</a><br /></td></tr>
<tr class="separator:a23f3600540de47d20e85eb4036af6e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a621a6133ce4203b8bfa351d5de4ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#aa3a621a6133ce4203b8bfa351d5de4ea">Cudd_SetMaxGrowth</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, double mg)</td></tr>
<tr class="memdesc:aa3a621a6133ce4203b8bfa351d5de4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maxGrowth parameter of the manager.  <a href="#aa3a621a6133ce4203b8bfa351d5de4ea">More...</a><br /></td></tr>
<tr class="separator:aa3a621a6133ce4203b8bfa351d5de4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692abb5fde2011b2a3cec010946eebca"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a692abb5fde2011b2a3cec010946eebca">Cudd_ReadMaxGrowthAlternate</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a692abb5fde2011b2a3cec010946eebca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the maxGrowthAlt parameter of the manager.  <a href="#a692abb5fde2011b2a3cec010946eebca">More...</a><br /></td></tr>
<tr class="separator:a692abb5fde2011b2a3cec010946eebca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4358c1f00a31b657c937b8e64ec6e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a7d4358c1f00a31b657c937b8e64ec6e6">Cudd_SetMaxGrowthAlternate</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, double mg)</td></tr>
<tr class="memdesc:a7d4358c1f00a31b657c937b8e64ec6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maxGrowthAlt parameter of the manager.  <a href="#a7d4358c1f00a31b657c937b8e64ec6e6">More...</a><br /></td></tr>
<tr class="separator:a7d4358c1f00a31b657c937b8e64ec6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5283d665223378e10425342dad1684b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#aa5283d665223378e10425342dad1684b">Cudd_ReadReorderingCycle</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:aa5283d665223378e10425342dad1684b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the reordCycle parameter of the manager.  <a href="#aa5283d665223378e10425342dad1684b">More...</a><br /></td></tr>
<tr class="separator:aa5283d665223378e10425342dad1684b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd23a86c046d74935d746757846d1148"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#afd23a86c046d74935d746757846d1148">Cudd_SetReorderingCycle</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int cycle)</td></tr>
<tr class="memdesc:afd23a86c046d74935d746757846d1148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reordCycle parameter of the manager.  <a href="#afd23a86c046d74935d746757846d1148">More...</a><br /></td></tr>
<tr class="separator:afd23a86c046d74935d746757846d1148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee8468f5b7fe67a0f609412e211632b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mtr_8h.html#ac77933bac85945a324b3ddacebbe899b">MtrNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a6ee8468f5b7fe67a0f609412e211632b">Cudd_ReadTree</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a6ee8468f5b7fe67a0f609412e211632b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variable group tree of the manager.  <a href="#a6ee8468f5b7fe67a0f609412e211632b">More...</a><br /></td></tr>
<tr class="separator:a6ee8468f5b7fe67a0f609412e211632b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa3827dfffcc29254520628b15aab55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a2aa3827dfffcc29254520628b15aab55">Cudd_SetTree</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="mtr_8h.html#ac77933bac85945a324b3ddacebbe899b">MtrNode</a> *tree)</td></tr>
<tr class="memdesc:a2aa3827dfffcc29254520628b15aab55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the variable group tree of the manager.  <a href="#a2aa3827dfffcc29254520628b15aab55">More...</a><br /></td></tr>
<tr class="separator:a2aa3827dfffcc29254520628b15aab55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c6ecb39244a6db49494d1f1e31bd1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#af5c6ecb39244a6db49494d1f1e31bd1a">Cudd_FreeTree</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:af5c6ecb39244a6db49494d1f1e31bd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the variable group tree of the manager.  <a href="#af5c6ecb39244a6db49494d1f1e31bd1a">More...</a><br /></td></tr>
<tr class="separator:af5c6ecb39244a6db49494d1f1e31bd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d3dbe0fa509a7f70691dcb6d8726ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mtr_8h.html#ac77933bac85945a324b3ddacebbe899b">MtrNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ad3d3dbe0fa509a7f70691dcb6d8726ad">Cudd_ReadZddTree</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ad3d3dbe0fa509a7f70691dcb6d8726ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variable group tree of the manager.  <a href="#ad3d3dbe0fa509a7f70691dcb6d8726ad">More...</a><br /></td></tr>
<tr class="separator:ad3d3dbe0fa509a7f70691dcb6d8726ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdbbc9e78a4f0684a118f304eb1a455"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a2cdbbc9e78a4f0684a118f304eb1a455">Cudd_SetZddTree</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="mtr_8h.html#ac77933bac85945a324b3ddacebbe899b">MtrNode</a> *tree)</td></tr>
<tr class="memdesc:a2cdbbc9e78a4f0684a118f304eb1a455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ZDD variable group tree of the manager.  <a href="#a2cdbbc9e78a4f0684a118f304eb1a455">More...</a><br /></td></tr>
<tr class="separator:a2cdbbc9e78a4f0684a118f304eb1a455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a25622e38ad302c050803d520f5fce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ac9a25622e38ad302c050803d520f5fce">Cudd_FreeZddTree</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ac9a25622e38ad302c050803d520f5fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the variable group tree of the manager.  <a href="#ac9a25622e38ad302c050803d520f5fce">More...</a><br /></td></tr>
<tr class="separator:ac9a25622e38ad302c050803d520f5fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c38a74f4362bd57bcb44593a3f515d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a53c38a74f4362bd57bcb44593a3f515d">Cudd_NodeReadIndex</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a53c38a74f4362bd57bcb44593a3f515d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the node.  <a href="#a53c38a74f4362bd57bcb44593a3f515d">More...</a><br /></td></tr>
<tr class="separator:a53c38a74f4362bd57bcb44593a3f515d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfa59899b792c9f47a612ceba42c976"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#aacfa59899b792c9f47a612ceba42c976">Cudd_ReadPerm</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int i)</td></tr>
<tr class="memdesc:aacfa59899b792c9f47a612ceba42c976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current position of the i-th variable in the order.  <a href="#aacfa59899b792c9f47a612ceba42c976">More...</a><br /></td></tr>
<tr class="separator:aacfa59899b792c9f47a612ceba42c976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965c64ce6822b03441ce7445e8187aa3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a965c64ce6822b03441ce7445e8187aa3">Cudd_ReadPermZdd</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int i)</td></tr>
<tr class="memdesc:a965c64ce6822b03441ce7445e8187aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current position of the i-th ZDD variable in the order.  <a href="#a965c64ce6822b03441ce7445e8187aa3">More...</a><br /></td></tr>
<tr class="separator:a965c64ce6822b03441ce7445e8187aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16ce73ed2e5afcd0dd1c1db43884d2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ae16ce73ed2e5afcd0dd1c1db43884d2a">Cudd_ReadInvPerm</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int i)</td></tr>
<tr class="memdesc:ae16ce73ed2e5afcd0dd1c1db43884d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the variable currently in the i-th position of the order.  <a href="#ae16ce73ed2e5afcd0dd1c1db43884d2a">More...</a><br /></td></tr>
<tr class="separator:ae16ce73ed2e5afcd0dd1c1db43884d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f47219044e26a1be7699014dcc021a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a30f47219044e26a1be7699014dcc021a">Cudd_ReadInvPermZdd</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int i)</td></tr>
<tr class="memdesc:a30f47219044e26a1be7699014dcc021a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the ZDD variable currently in the i-th position of the order.  <a href="#a30f47219044e26a1be7699014dcc021a">More...</a><br /></td></tr>
<tr class="separator:a30f47219044e26a1be7699014dcc021a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d8f64c98953fd110d0e5146bcadaca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a44d8f64c98953fd110d0e5146bcadaca">Cudd_ReadVars</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int i)</td></tr>
<tr class="memdesc:a44d8f64c98953fd110d0e5146bcadaca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the i-th element of the vars array.  <a href="#a44d8f64c98953fd110d0e5146bcadaca">More...</a><br /></td></tr>
<tr class="separator:a44d8f64c98953fd110d0e5146bcadaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac711d8ce9d243e16246b83e3c1f04199"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ac711d8ce9d243e16246b83e3c1f04199">Cudd_ReadEpsilon</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ac711d8ce9d243e16246b83e3c1f04199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the epsilon parameter of the manager.  <a href="#ac711d8ce9d243e16246b83e3c1f04199">More...</a><br /></td></tr>
<tr class="separator:ac711d8ce9d243e16246b83e3c1f04199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ef132c1f56bdb0e26efc81fa695cf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a30ef132c1f56bdb0e26efc81fa695cf3">Cudd_SetEpsilon</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> ep)</td></tr>
<tr class="memdesc:a30ef132c1f56bdb0e26efc81fa695cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the epsilon parameter of the manager to ep.  <a href="#a30ef132c1f56bdb0e26efc81fa695cf3">More...</a><br /></td></tr>
<tr class="separator:a30ef132c1f56bdb0e26efc81fa695cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2639c79f7b9c58367cbfc0f55ca3b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#a8b2572b778b7e8bd68afcd4aa1f0ce33">Cudd_AggregationType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a8f2639c79f7b9c58367cbfc0f55ca3b5">Cudd_ReadGroupcheck</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a8f2639c79f7b9c58367cbfc0f55ca3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the groupcheck parameter of the manager.  <a href="#a8f2639c79f7b9c58367cbfc0f55ca3b5">More...</a><br /></td></tr>
<tr class="separator:a8f2639c79f7b9c58367cbfc0f55ca3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7e7fa94656ed131aa67ca1ea15a031"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#aee7e7fa94656ed131aa67ca1ea15a031">Cudd_SetGroupcheck</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="cudd_8h.html#a8b2572b778b7e8bd68afcd4aa1f0ce33">Cudd_AggregationType</a> gc)</td></tr>
<tr class="memdesc:aee7e7fa94656ed131aa67ca1ea15a031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the parameter groupcheck of the manager to gc.  <a href="#aee7e7fa94656ed131aa67ca1ea15a031">More...</a><br /></td></tr>
<tr class="separator:aee7e7fa94656ed131aa67ca1ea15a031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf441cdb56f24a9e3e20f6e87cc571c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#adf441cdb56f24a9e3e20f6e87cc571c8">Cudd_GarbageCollectionEnabled</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:adf441cdb56f24a9e3e20f6e87cc571c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether garbage collection is enabled.  <a href="#adf441cdb56f24a9e3e20f6e87cc571c8">More...</a><br /></td></tr>
<tr class="separator:adf441cdb56f24a9e3e20f6e87cc571c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a5511bcc805af71fc1fb5abba96f1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a95a5511bcc805af71fc1fb5abba96f1e">Cudd_EnableGarbageCollection</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a95a5511bcc805af71fc1fb5abba96f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables garbage collection.  <a href="#a95a5511bcc805af71fc1fb5abba96f1e">More...</a><br /></td></tr>
<tr class="separator:a95a5511bcc805af71fc1fb5abba96f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1def55437ab00e012fba1a98bc3a941"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ab1def55437ab00e012fba1a98bc3a941">Cudd_DisableGarbageCollection</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ab1def55437ab00e012fba1a98bc3a941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables garbage collection.  <a href="#ab1def55437ab00e012fba1a98bc3a941">More...</a><br /></td></tr>
<tr class="separator:ab1def55437ab00e012fba1a98bc3a941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34d186620ce66627e57bbccfa24a892"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ae34d186620ce66627e57bbccfa24a892">Cudd_DeadAreCounted</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ae34d186620ce66627e57bbccfa24a892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether dead nodes are counted towards triggering reordering.  <a href="#ae34d186620ce66627e57bbccfa24a892">More...</a><br /></td></tr>
<tr class="separator:ae34d186620ce66627e57bbccfa24a892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b407453f68498df9b9783f88401cf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#af0b407453f68498df9b9783f88401cf5">Cudd_TurnOnCountDead</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:af0b407453f68498df9b9783f88401cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the dead nodes to be counted towards triggering reordering.  <a href="#af0b407453f68498df9b9783f88401cf5">More...</a><br /></td></tr>
<tr class="separator:af0b407453f68498df9b9783f88401cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b822894a35380ffca9e555286213484"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a5b822894a35380ffca9e555286213484">Cudd_TurnOffCountDead</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a5b822894a35380ffca9e555286213484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the dead nodes not to be counted towards triggering reordering.  <a href="#a5b822894a35380ffca9e555286213484">More...</a><br /></td></tr>
<tr class="separator:a5b822894a35380ffca9e555286213484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac305e7d5aaa2c3808db94795dc0a1150"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ac305e7d5aaa2c3808db94795dc0a1150">Cudd_ReadRecomb</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ac305e7d5aaa2c3808db94795dc0a1150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value of the recombination parameter used in group sifting.  <a href="#ac305e7d5aaa2c3808db94795dc0a1150">More...</a><br /></td></tr>
<tr class="separator:ac305e7d5aaa2c3808db94795dc0a1150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68f934b27bc1d1ea947f410c8aedd36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ac68f934b27bc1d1ea947f410c8aedd36">Cudd_SetRecomb</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int recomb)</td></tr>
<tr class="memdesc:ac68f934b27bc1d1ea947f410c8aedd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the recombination parameter used in group sifting.  <a href="#ac68f934b27bc1d1ea947f410c8aedd36">More...</a><br /></td></tr>
<tr class="separator:ac68f934b27bc1d1ea947f410c8aedd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3028ccbe6fb46efd6565d0f4aab78738"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a3028ccbe6fb46efd6565d0f4aab78738">Cudd_ReadSymmviolation</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a3028ccbe6fb46efd6565d0f4aab78738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value of the symmviolation parameter used in group sifting.  <a href="#a3028ccbe6fb46efd6565d0f4aab78738">More...</a><br /></td></tr>
<tr class="separator:a3028ccbe6fb46efd6565d0f4aab78738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb84b628160417172cb44e22e2067b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a5bb84b628160417172cb44e22e2067b7">Cudd_SetSymmviolation</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int symmviolation)</td></tr>
<tr class="memdesc:a5bb84b628160417172cb44e22e2067b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the symmviolation parameter used in group sifting.  <a href="#a5bb84b628160417172cb44e22e2067b7">More...</a><br /></td></tr>
<tr class="separator:a5bb84b628160417172cb44e22e2067b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89117a52be055c338311b1380d511375"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a89117a52be055c338311b1380d511375">Cudd_ReadArcviolation</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a89117a52be055c338311b1380d511375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value of the arcviolation parameter used in group sifting.  <a href="#a89117a52be055c338311b1380d511375">More...</a><br /></td></tr>
<tr class="separator:a89117a52be055c338311b1380d511375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3064405f352a9d93a6ee16cfa5d2512c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a3064405f352a9d93a6ee16cfa5d2512c">Cudd_SetArcviolation</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int arcviolation)</td></tr>
<tr class="memdesc:a3064405f352a9d93a6ee16cfa5d2512c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the arcviolation parameter used in group sifting.  <a href="#a3064405f352a9d93a6ee16cfa5d2512c">More...</a><br /></td></tr>
<tr class="separator:a3064405f352a9d93a6ee16cfa5d2512c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e760e63a14cd28172b2371c8419b0d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a1e760e63a14cd28172b2371c8419b0d9">Cudd_ReadPopulationSize</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a1e760e63a14cd28172b2371c8419b0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the current size of the population used by the genetic algorithm for variable reordering.  <a href="#a1e760e63a14cd28172b2371c8419b0d9">More...</a><br /></td></tr>
<tr class="separator:a1e760e63a14cd28172b2371c8419b0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdf2ca87a414bb36bfbb6247a8915ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#abbdf2ca87a414bb36bfbb6247a8915ec">Cudd_SetPopulationSize</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int populationSize)</td></tr>
<tr class="memdesc:abbdf2ca87a414bb36bfbb6247a8915ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the population used by the genetic algorithm for variable reordering.  <a href="#abbdf2ca87a414bb36bfbb6247a8915ec">More...</a><br /></td></tr>
<tr class="separator:abbdf2ca87a414bb36bfbb6247a8915ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2609fe9051be1a8ab6d305d38bfb5956"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a2609fe9051be1a8ab6d305d38bfb5956">Cudd_ReadNumberXovers</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a2609fe9051be1a8ab6d305d38bfb5956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the current number of crossovers used by the genetic algorithm for variable reordering.  <a href="#a2609fe9051be1a8ab6d305d38bfb5956">More...</a><br /></td></tr>
<tr class="separator:a2609fe9051be1a8ab6d305d38bfb5956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b2c48e26b4178cf6536f4ce253d9b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ae8b2c48e26b4178cf6536f4ce253d9b1">Cudd_SetNumberXovers</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int numberXovers)</td></tr>
<tr class="memdesc:ae8b2c48e26b4178cf6536f4ce253d9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of crossovers used by the genetic algorithm for variable reordering.  <a href="#ae8b2c48e26b4178cf6536f4ce253d9b1">More...</a><br /></td></tr>
<tr class="separator:ae8b2c48e26b4178cf6536f4ce253d9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f6c6fc1714330d1554a0f2e562ae1f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a93f6c6fc1714330d1554a0f2e562ae1f">Cudd_ReadOrderRandomization</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a93f6c6fc1714330d1554a0f2e562ae1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the order randomization factor.  <a href="#a93f6c6fc1714330d1554a0f2e562ae1f">More...</a><br /></td></tr>
<tr class="separator:a93f6c6fc1714330d1554a0f2e562ae1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e58f1cfc002a5a2af126f29e7377243"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a3e58f1cfc002a5a2af126f29e7377243">Cudd_SetOrderRandomization</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, unsigned int factor)</td></tr>
<tr class="memdesc:a3e58f1cfc002a5a2af126f29e7377243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the order randomization factor.  <a href="#a3e58f1cfc002a5a2af126f29e7377243">More...</a><br /></td></tr>
<tr class="separator:a3e58f1cfc002a5a2af126f29e7377243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952c97ec2d8b0a73f759e7e993e1e367"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a952c97ec2d8b0a73f759e7e993e1e367">Cudd_ReadMemoryInUse</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a952c97ec2d8b0a73f759e7e993e1e367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memory in use by the manager measured in bytes.  <a href="#a952c97ec2d8b0a73f759e7e993e1e367">More...</a><br /></td></tr>
<tr class="separator:a952c97ec2d8b0a73f759e7e993e1e367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0883e74086d9f61c2988ba614e9e649e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a0883e74086d9f61c2988ba614e9e649e">Cudd_PrintInfo</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, FILE *fp)</td></tr>
<tr class="memdesc:a0883e74086d9f61c2988ba614e9e649e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints out statistics and settings for a CUDD manager.  <a href="#a0883e74086d9f61c2988ba614e9e649e">More...</a><br /></td></tr>
<tr class="separator:a0883e74086d9f61c2988ba614e9e649e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39633df05be731b6b145d65f83aed572"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a39633df05be731b6b145d65f83aed572">Cudd_ReadPeakNodeCount</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a39633df05be731b6b145d65f83aed572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the peak number of nodes.  <a href="#a39633df05be731b6b145d65f83aed572">More...</a><br /></td></tr>
<tr class="separator:a39633df05be731b6b145d65f83aed572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120dd8ff3d2b0a4df7600a820175f1d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a120dd8ff3d2b0a4df7600a820175f1d4">Cudd_ReadPeakLiveNodeCount</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a120dd8ff3d2b0a4df7600a820175f1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the peak number of live nodes.  <a href="#a120dd8ff3d2b0a4df7600a820175f1d4">More...</a><br /></td></tr>
<tr class="separator:a120dd8ff3d2b0a4df7600a820175f1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba2c88b8f70df51791c26ffde800fc7"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a9ba2c88b8f70df51791c26ffde800fc7">Cudd_ReadNodeCount</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a9ba2c88b8f70df51791c26ffde800fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the number of nodes in BDDs and ADDs.  <a href="#a9ba2c88b8f70df51791c26ffde800fc7">More...</a><br /></td></tr>
<tr class="separator:a9ba2c88b8f70df51791c26ffde800fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c015c746d9c71fb9b57249f2a4ccd72"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a4c015c746d9c71fb9b57249f2a4ccd72">Cudd_zddReadNodeCount</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a4c015c746d9c71fb9b57249f2a4ccd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the number of nodes in ZDDs.  <a href="#a4c015c746d9c71fb9b57249f2a4ccd72">More...</a><br /></td></tr>
<tr class="separator:a4c015c746d9c71fb9b57249f2a4ccd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6884f064de544463f006f9104e4afa74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a6884f064de544463f006f9104e4afa74">Cudd_AddHook</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="cudd_8h.html#a1a0b162633be038685ce87dac7a57382">DD_HFP</a> f, <a class="el" href="cudd_8h.html#afbec19daded82939f6045c92b3a7bde2">Cudd_HookType</a> where)</td></tr>
<tr class="memdesc:a6884f064de544463f006f9104e4afa74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a function to a hook.  <a href="#a6884f064de544463f006f9104e4afa74">More...</a><br /></td></tr>
<tr class="separator:a6884f064de544463f006f9104e4afa74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c732be4af510054662cd6e6f0a5772f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a0c732be4af510054662cd6e6f0a5772f">Cudd_RemoveHook</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="cudd_8h.html#a1a0b162633be038685ce87dac7a57382">DD_HFP</a> f, <a class="el" href="cudd_8h.html#afbec19daded82939f6045c92b3a7bde2">Cudd_HookType</a> where)</td></tr>
<tr class="memdesc:a0c732be4af510054662cd6e6f0a5772f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a function from a hook.  <a href="#a0c732be4af510054662cd6e6f0a5772f">More...</a><br /></td></tr>
<tr class="separator:a0c732be4af510054662cd6e6f0a5772f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55eb04332db0a87f173b7638080ec856"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a55eb04332db0a87f173b7638080ec856">Cudd_IsInHook</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="cudd_8h.html#a1a0b162633be038685ce87dac7a57382">DD_HFP</a> f, <a class="el" href="cudd_8h.html#afbec19daded82939f6045c92b3a7bde2">Cudd_HookType</a> where)</td></tr>
<tr class="memdesc:a55eb04332db0a87f173b7638080ec856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a function is in a hook.  <a href="#a55eb04332db0a87f173b7638080ec856">More...</a><br /></td></tr>
<tr class="separator:a55eb04332db0a87f173b7638080ec856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852da7502c07042fde873b504aaa4573"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a852da7502c07042fde873b504aaa4573">Cudd_StdPreReordHook</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, const char *str, void *data)</td></tr>
<tr class="memdesc:a852da7502c07042fde873b504aaa4573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample hook function to call before reordering.  <a href="#a852da7502c07042fde873b504aaa4573">More...</a><br /></td></tr>
<tr class="separator:a852da7502c07042fde873b504aaa4573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b17a13db3a9537a0a13df5507f4d11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#aa3b17a13db3a9537a0a13df5507f4d11">Cudd_StdPostReordHook</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, const char *str, void *data)</td></tr>
<tr class="memdesc:aa3b17a13db3a9537a0a13df5507f4d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample hook function to call after reordering.  <a href="#aa3b17a13db3a9537a0a13df5507f4d11">More...</a><br /></td></tr>
<tr class="separator:aa3b17a13db3a9537a0a13df5507f4d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe5374e85cf3fb0827307b1e3cc5e07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#adfe5374e85cf3fb0827307b1e3cc5e07">Cudd_EnableReorderingReporting</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:adfe5374e85cf3fb0827307b1e3cc5e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables reporting of reordering stats.  <a href="#adfe5374e85cf3fb0827307b1e3cc5e07">More...</a><br /></td></tr>
<tr class="separator:adfe5374e85cf3fb0827307b1e3cc5e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249298e38710246ab1ead014cfe54dd9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a249298e38710246ab1ead014cfe54dd9">Cudd_DisableReorderingReporting</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a249298e38710246ab1ead014cfe54dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables reporting of reordering stats.  <a href="#a249298e38710246ab1ead014cfe54dd9">More...</a><br /></td></tr>
<tr class="separator:a249298e38710246ab1ead014cfe54dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a634a339969d6d84e3db858f3f77be4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a4a634a339969d6d84e3db858f3f77be4">Cudd_ReorderingReporting</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a4a634a339969d6d84e3db858f3f77be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if reporting of reordering stats is enabled; 0 otherwise.  <a href="#a4a634a339969d6d84e3db858f3f77be4">More...</a><br /></td></tr>
<tr class="separator:a4a634a339969d6d84e3db858f3f77be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba970524139c009227b2fa0fc8cac0eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#aba970524139c009227b2fa0fc8cac0eb">Cudd_PrintGroupedOrder</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, const char *str, void *data)</td></tr>
<tr class="memdesc:aba970524139c009227b2fa0fc8cac0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook function to print the current variable order.  <a href="#aba970524139c009227b2fa0fc8cac0eb">More...</a><br /></td></tr>
<tr class="separator:aba970524139c009227b2fa0fc8cac0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa547783b2cd3e54062864543fba0de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a6aa547783b2cd3e54062864543fba0de">Cudd_EnableOrderingMonitoring</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a6aa547783b2cd3e54062864543fba0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables monitoring of ordering.  <a href="#a6aa547783b2cd3e54062864543fba0de">More...</a><br /></td></tr>
<tr class="separator:a6aa547783b2cd3e54062864543fba0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1363eeb294a402d754f142c2022d4562"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a1363eeb294a402d754f142c2022d4562">Cudd_DisableOrderingMonitoring</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a1363eeb294a402d754f142c2022d4562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables monitoring of ordering.  <a href="#a1363eeb294a402d754f142c2022d4562">More...</a><br /></td></tr>
<tr class="separator:a1363eeb294a402d754f142c2022d4562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d721c40b8c47401a0739027cf5a571"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a93d721c40b8c47401a0739027cf5a571">Cudd_OrderingMonitoring</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a93d721c40b8c47401a0739027cf5a571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if monitoring of ordering is enabled; 0 otherwise.  <a href="#a93d721c40b8c47401a0739027cf5a571">More...</a><br /></td></tr>
<tr class="separator:a93d721c40b8c47401a0739027cf5a571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4a097e769d11868f760b920e6f1da8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a2d4a097e769d11868f760b920e6f1da8">Cudd_SetApplicationHook</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, void *value)</td></tr>
<tr class="memdesc:a2d4a097e769d11868f760b920e6f1da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the application hook.  <a href="#a2d4a097e769d11868f760b920e6f1da8">More...</a><br /></td></tr>
<tr class="separator:a2d4a097e769d11868f760b920e6f1da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f98975109e7d3afd1bad0716e4d6666"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a9f98975109e7d3afd1bad0716e4d6666">Cudd_ReadApplicationHook</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a9f98975109e7d3afd1bad0716e4d6666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the application hook.  <a href="#a9f98975109e7d3afd1bad0716e4d6666">More...</a><br /></td></tr>
<tr class="separator:a9f98975109e7d3afd1bad0716e4d6666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988b83058c815b1ca112c6a9c74525ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#a27114b4342bc1b987f35d751eae2444b">Cudd_ErrorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a988b83058c815b1ca112c6a9c74525ad">Cudd_ReadErrorCode</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a988b83058c815b1ca112c6a9c74525ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the code of the last error.  <a href="#a988b83058c815b1ca112c6a9c74525ad">More...</a><br /></td></tr>
<tr class="separator:a988b83058c815b1ca112c6a9c74525ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3a189c261ed9f698ace55ade32af01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#aed3a189c261ed9f698ace55ade32af01">Cudd_ClearErrorCode</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:aed3a189c261ed9f698ace55ade32af01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the error code of a manager.  <a href="#aed3a189c261ed9f698ace55ade32af01">More...</a><br /></td></tr>
<tr class="separator:aed3a189c261ed9f698ace55ade32af01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8941f373e5e1156b2e42af09f4247d47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#ab7b4676c7e2dd36567b3749740ca8b60">DD_OOMFP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a8941f373e5e1156b2e42af09f4247d47">Cudd_InstallOutOfMemoryHandler</a> (<a class="el" href="cudd_8h.html#ab7b4676c7e2dd36567b3749740ca8b60">DD_OOMFP</a> newHandler)</td></tr>
<tr class="memdesc:a8941f373e5e1156b2e42af09f4247d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a handler for failed memory allocations.  <a href="#a8941f373e5e1156b2e42af09f4247d47">More...</a><br /></td></tr>
<tr class="separator:a8941f373e5e1156b2e42af09f4247d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811b2599d1ed4a66001b7577cbbbd33d"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a811b2599d1ed4a66001b7577cbbbd33d">Cudd_ReadStdout</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a811b2599d1ed4a66001b7577cbbbd33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the stdout of a manager.  <a href="#a811b2599d1ed4a66001b7577cbbbd33d">More...</a><br /></td></tr>
<tr class="separator:a811b2599d1ed4a66001b7577cbbbd33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3080103403d6ba1f79b04f4e701edbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ac3080103403d6ba1f79b04f4e701edbc">Cudd_SetStdout</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, FILE *fp)</td></tr>
<tr class="memdesc:ac3080103403d6ba1f79b04f4e701edbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the stdout of a manager.  <a href="#ac3080103403d6ba1f79b04f4e701edbc">More...</a><br /></td></tr>
<tr class="separator:ac3080103403d6ba1f79b04f4e701edbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9830fe86096e7721263e058ba7d93d26"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a9830fe86096e7721263e058ba7d93d26">Cudd_ReadStderr</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a9830fe86096e7721263e058ba7d93d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the stderr of a manager.  <a href="#a9830fe86096e7721263e058ba7d93d26">More...</a><br /></td></tr>
<tr class="separator:a9830fe86096e7721263e058ba7d93d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910e7309dc7551140d71871619ead247"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a910e7309dc7551140d71871619ead247">Cudd_SetStderr</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, FILE *fp)</td></tr>
<tr class="memdesc:a910e7309dc7551140d71871619ead247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the stderr of a manager.  <a href="#a910e7309dc7551140d71871619ead247">More...</a><br /></td></tr>
<tr class="separator:a910e7309dc7551140d71871619ead247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3820fb326bce09797fda8439b5daa4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#adc3820fb326bce09797fda8439b5daa4">Cudd_ReadNextReordering</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:adc3820fb326bce09797fda8439b5daa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the threshold for the next dynamic reordering.  <a href="#adc3820fb326bce09797fda8439b5daa4">More...</a><br /></td></tr>
<tr class="separator:adc3820fb326bce09797fda8439b5daa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d62c965eabd4ec777af47acd790ee47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a3d62c965eabd4ec777af47acd790ee47">Cudd_SetNextReordering</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, unsigned int next)</td></tr>
<tr class="memdesc:a3d62c965eabd4ec777af47acd790ee47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the threshold for the next dynamic reordering.  <a href="#a3d62c965eabd4ec777af47acd790ee47">More...</a><br /></td></tr>
<tr class="separator:a3d62c965eabd4ec777af47acd790ee47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb92ccf940cabf261d35ccc1945e7cf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a2cb92ccf940cabf261d35ccc1945e7cf">Cudd_ReadSwapSteps</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a2cb92ccf940cabf261d35ccc1945e7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the number of elementary reordering steps.  <a href="#a2cb92ccf940cabf261d35ccc1945e7cf">More...</a><br /></td></tr>
<tr class="separator:a2cb92ccf940cabf261d35ccc1945e7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6afbdb9c3955275888ec9cb60711a57"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#af6afbdb9c3955275888ec9cb60711a57">Cudd_ReadMaxLive</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:af6afbdb9c3955275888ec9cb60711a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the maximum allowed number of live nodes.  <a href="#af6afbdb9c3955275888ec9cb60711a57">More...</a><br /></td></tr>
<tr class="separator:af6afbdb9c3955275888ec9cb60711a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac553f7975b60ebe4a38141cbff1eebea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ac553f7975b60ebe4a38141cbff1eebea">Cudd_SetMaxLive</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, unsigned int maxLive)</td></tr>
<tr class="memdesc:ac553f7975b60ebe4a38141cbff1eebea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum allowed number of live nodes.  <a href="#ac553f7975b60ebe4a38141cbff1eebea">More...</a><br /></td></tr>
<tr class="separator:ac553f7975b60ebe4a38141cbff1eebea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef52798a6b7994a3038335d36ec9f051"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#aef52798a6b7994a3038335d36ec9f051">Cudd_ReadMaxMemory</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:aef52798a6b7994a3038335d36ec9f051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the maximum allowed memory.  <a href="#aef52798a6b7994a3038335d36ec9f051">More...</a><br /></td></tr>
<tr class="separator:aef52798a6b7994a3038335d36ec9f051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d15a525874908e9230881bccabbb993"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a0d15a525874908e9230881bccabbb993">Cudd_SetMaxMemory</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, size_t maxMemory)</td></tr>
<tr class="memdesc:a0d15a525874908e9230881bccabbb993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum allowed memory.  <a href="#a0d15a525874908e9230881bccabbb993">More...</a><br /></td></tr>
<tr class="separator:a0d15a525874908e9230881bccabbb993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acdc5b22c44f316a98c894998ca93d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a5acdc5b22c44f316a98c894998ca93d8">Cudd_bddBindVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a5acdc5b22c44f316a98c894998ca93d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents sifting of a variable.  <a href="#a5acdc5b22c44f316a98c894998ca93d8">More...</a><br /></td></tr>
<tr class="separator:a5acdc5b22c44f316a98c894998ca93d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944f587db5ad4427ea36912313adccaa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a944f587db5ad4427ea36912313adccaa">Cudd_bddUnbindVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a944f587db5ad4427ea36912313adccaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the sifting of a variable.  <a href="#a944f587db5ad4427ea36912313adccaa">More...</a><br /></td></tr>
<tr class="separator:a944f587db5ad4427ea36912313adccaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d01993b4162e8ece02e339ecb0a456"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a88d01993b4162e8ece02e339ecb0a456">Cudd_bddVarIsBound</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a88d01993b4162e8ece02e339ecb0a456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether a variable can be sifted.  <a href="#a88d01993b4162e8ece02e339ecb0a456">More...</a><br /></td></tr>
<tr class="separator:a88d01993b4162e8ece02e339ecb0a456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6849dc17bbba2043922cb0efcd21ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#aac6849dc17bbba2043922cb0efcd21ec">Cudd_bddSetPiVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:aac6849dc17bbba2043922cb0efcd21ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a variable type to primary input.  <a href="#aac6849dc17bbba2043922cb0efcd21ec">More...</a><br /></td></tr>
<tr class="separator:aac6849dc17bbba2043922cb0efcd21ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8deaa5bc364ba47901043ea405b6909"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ac8deaa5bc364ba47901043ea405b6909">Cudd_bddSetPsVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:ac8deaa5bc364ba47901043ea405b6909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a variable type to present state.  <a href="#ac8deaa5bc364ba47901043ea405b6909">More...</a><br /></td></tr>
<tr class="separator:ac8deaa5bc364ba47901043ea405b6909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9259947e31d7d43fee7209e08e0257f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a9259947e31d7d43fee7209e08e0257f0">Cudd_bddSetNsVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a9259947e31d7d43fee7209e08e0257f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a variable type to next state.  <a href="#a9259947e31d7d43fee7209e08e0257f0">More...</a><br /></td></tr>
<tr class="separator:a9259947e31d7d43fee7209e08e0257f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8807a8333099dbd0d32cccf9da8841b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a8807a8333099dbd0d32cccf9da8841b2">Cudd_bddIsPiVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a8807a8333099dbd0d32cccf9da8841b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a variable is primary input.  <a href="#a8807a8333099dbd0d32cccf9da8841b2">More...</a><br /></td></tr>
<tr class="separator:a8807a8333099dbd0d32cccf9da8841b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390b021da58cb55e9c912f4490a5845e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a390b021da58cb55e9c912f4490a5845e">Cudd_bddIsPsVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a390b021da58cb55e9c912f4490a5845e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a variable is present state.  <a href="#a390b021da58cb55e9c912f4490a5845e">More...</a><br /></td></tr>
<tr class="separator:a390b021da58cb55e9c912f4490a5845e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4fca0bea12745bf32f153a72dc269f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a5f4fca0bea12745bf32f153a72dc269f">Cudd_bddIsNsVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a5f4fca0bea12745bf32f153a72dc269f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a variable is next state.  <a href="#a5f4fca0bea12745bf32f153a72dc269f">More...</a><br /></td></tr>
<tr class="separator:a5f4fca0bea12745bf32f153a72dc269f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11beec034c2fc7842ca370aaeed9b21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ac11beec034c2fc7842ca370aaeed9b21">Cudd_bddSetPairIndex</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index, int pairIndex)</td></tr>
<tr class="memdesc:ac11beec034c2fc7842ca370aaeed9b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a corresponding pair index for a given index.  <a href="#ac11beec034c2fc7842ca370aaeed9b21">More...</a><br /></td></tr>
<tr class="separator:ac11beec034c2fc7842ca370aaeed9b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642b76a558f6dafd89648f9f7c470b68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a642b76a558f6dafd89648f9f7c470b68">Cudd_bddReadPairIndex</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a642b76a558f6dafd89648f9f7c470b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a corresponding pair index for a given index.  <a href="#a642b76a558f6dafd89648f9f7c470b68">More...</a><br /></td></tr>
<tr class="separator:a642b76a558f6dafd89648f9f7c470b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776ff1149be00414f9dfb9d8e5236b6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a776ff1149be00414f9dfb9d8e5236b6a">Cudd_bddSetVarToBeGrouped</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a776ff1149be00414f9dfb9d8e5236b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a variable to be grouped.  <a href="#a776ff1149be00414f9dfb9d8e5236b6a">More...</a><br /></td></tr>
<tr class="separator:a776ff1149be00414f9dfb9d8e5236b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3008fcc7c507d061c10a343a6c01ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a2f3008fcc7c507d061c10a343a6c01ce">Cudd_bddSetVarHardGroup</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a2f3008fcc7c507d061c10a343a6c01ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a variable to be a hard group.  <a href="#a2f3008fcc7c507d061c10a343a6c01ce">More...</a><br /></td></tr>
<tr class="separator:a2f3008fcc7c507d061c10a343a6c01ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8613c4063493aebe3dc9e0e14562114"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#ac8613c4063493aebe3dc9e0e14562114">Cudd_bddResetVarToBeGrouped</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:ac8613c4063493aebe3dc9e0e14562114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a variable not to be grouped.  <a href="#ac8613c4063493aebe3dc9e0e14562114">More...</a><br /></td></tr>
<tr class="separator:ac8613c4063493aebe3dc9e0e14562114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956ea07041f3e4f560bc936404461b2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a956ea07041f3e4f560bc936404461b2a">Cudd_bddIsVarToBeGrouped</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a956ea07041f3e4f560bc936404461b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a variable is set to be grouped.  <a href="#a956ea07041f3e4f560bc936404461b2a">More...</a><br /></td></tr>
<tr class="separator:a956ea07041f3e4f560bc936404461b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd0386d3adadf96af5a95939586dc7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#acdd0386d3adadf96af5a95939586dc7b">Cudd_bddSetVarToBeUngrouped</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:acdd0386d3adadf96af5a95939586dc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a variable to be ungrouped.  <a href="#acdd0386d3adadf96af5a95939586dc7b">More...</a><br /></td></tr>
<tr class="separator:acdd0386d3adadf96af5a95939586dc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0ef3b582414eb1907ad98fb4cc16e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a8e0ef3b582414eb1907ad98fb4cc16e9">Cudd_bddIsVarToBeUngrouped</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a8e0ef3b582414eb1907ad98fb4cc16e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a variable is set to be ungrouped.  <a href="#a8e0ef3b582414eb1907ad98fb4cc16e9">More...</a><br /></td></tr>
<tr class="separator:a8e0ef3b582414eb1907ad98fb4cc16e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14eda0885ab454e4e518639208e0c920"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a14eda0885ab454e4e518639208e0c920">Cudd_bddIsVarHardGroup</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a14eda0885ab454e4e518639208e0c920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a variable is set to be in a hard group.  <a href="#a14eda0885ab454e4e518639208e0c920">More...</a><br /></td></tr>
<tr class="separator:a14eda0885ab454e4e518639208e0c920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7571d0ca349667f3912593b8a7d8d1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a9a7571d0ca349667f3912593b8a7d8d1">fixVarTree</a> (<a class="el" href="mtr_8h.html#ac77933bac85945a324b3ddacebbe899b">MtrNode</a> *treenode, int *perm, int size)</td></tr>
<tr class="memdesc:a9a7571d0ca349667f3912593b8a7d8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixes a variable group tree.  <a href="#a9a7571d0ca349667f3912593b8a7d8d1">More...</a><br /></td></tr>
<tr class="separator:a9a7571d0ca349667f3912593b8a7d8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f5c23b943bb38144362698dc8b60ed"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddAPI_8c.html#a29f5c23b943bb38144362698dc8b60ed">addMultiplicityGroups</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="mtr_8h.html#ac77933bac85945a324b3ddacebbe899b">MtrNode</a> *treenode, int multiplicity, char *vmask, char *lmask)</td></tr>
<tr class="memdesc:a29f5c23b943bb38144362698dc8b60ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiplicity groups to a ZDD variable group tree.  <a href="#a29f5c23b943bb38144362698dc8b60ed">More...</a><br /></td></tr>
<tr class="separator:a29f5c23b943bb38144362698dc8b60ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Application interface functions. </p>
<dl class="section author"><dt>Author</dt><dd>Fabio Somenzi</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd><p class="startdd">Copyright (c) 1995-2015, Regents of the University of Colorado</p>
<p class="interdd">All rights reserved.</p>
<p class="interdd">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p class="interdd">Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p class="interdd">Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p class="interdd">Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p class="enddd">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a29f5c23b943bb38144362698dc8b60ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f5c23b943bb38144362698dc8b60ed">&#9670;&nbsp;</a></span>addMultiplicityGroups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int addMultiplicityGroups </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mtr_8h.html#ac77933bac85945a324b3ddacebbe899b">MtrNode</a> *&#160;</td>
          <td class="paramname"><em>treenode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>multiplicity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>vmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>lmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds multiplicity groups to a ZDD variable group tree. </p>
<p>This function creates the groups for set of ZDD variables (whose cardinality is given by parameter multiplicity) that are created for each BDD variable in Cudd_zddVarsFromBddVars. The crux of the matter is to determine the index each new group. (The index of the first variable in the group.) We first build all the groups for the children of a node, and then deal with the ZDD variables that are directly attached to the node. The problem for these is that the tree itself does not provide information on their position inside the group. While we deal with the children of the node, therefore, we keep track of all the positions they occupy. The remaining positions in the tree can be freely used. Also, we keep track of all the variables placed in the children. All the remaining variables are directly attached to the group. We can then place any pair of variables not yet grouped in any pair of available positions in the node.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n Changes the variable group tree.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a45d898e3087539ceaaf5ff86aa62c471" title="Creates one or more ZDD variables for each BDD variable.">Cudd_zddVarsFromBddVars</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">treenode</td><td>current tree node </td></tr>
    <tr><td class="paramname">multiplicity</td><td>how many ZDD vars per BDD var </td></tr>
    <tr><td class="paramname">vmask</td><td>variable pairs for which a group has been already built </td></tr>
    <tr><td class="paramname">lmask</td><td>levels for which a group has already been built </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b8fb347b6c5324ef9bce64aa73a63bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8fb347b6c5324ef9bce64aa73a63bb">&#9670;&nbsp;</a></span>Cudd_addConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ADD for constant c. </p>
<p>Retrieves the ADD for constant c if it already exists, or creates a new ADD.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ad77f4dd2911bac8e25633fe84c6cfb8b" title="Returns a new ADD variable.">Cudd_addNewVar</a> <a class="el" href="cuddAPI_8c.html#a19967d7c87650f63fc312f38c318e3e9" title="Returns the ADD variable with index i.">Cudd_addIthVar</a> </dd></dl>

</div>
</div>
<a id="a6884f064de544463f006f9104e4afa74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6884f064de544463f006f9104e4afa74">&#9670;&nbsp;</a></span>Cudd_AddHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_AddHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a1a0b162633be038685ce87dac7a57382">DD_HFP</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#afbec19daded82939f6045c92b3a7bde2">Cudd_HookType</a>&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a function to a hook. </p>
<p>A hook is a list of application-provided functions called on certain occasions by the package.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the function is successfully added; 2 if the function was already in the list; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a0c732be4af510054662cd6e6f0a5772f" title="Removes a function from a hook.">Cudd_RemoveHook</a> </dd></dl>

</div>
</div>
<a id="a19967d7c87650f63fc312f38c318e3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19967d7c87650f63fc312f38c318e3e9">&#9670;&nbsp;</a></span>Cudd_addIthVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addIthVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ADD variable with index i. </p>
<p>Retrieves the ADD variable with index i if it already exists, or creates a new ADD variable. An ADD variable differs from a BDD variable because it points to the arithmetic zero, instead of having a complement pointer to 1.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the variable if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ad77f4dd2911bac8e25633fe84c6cfb8b" title="Returns a new ADD variable.">Cudd_addNewVar</a> <a class="el" href="cuddAPI_8c.html#a40fd71665cde402bd5bc4f39015c09ae" title="Returns the BDD variable with index i.">Cudd_bddIthVar</a> <a class="el" href="cuddAPI_8c.html#a8b8fb347b6c5324ef9bce64aa73a63bb" title="Returns the ADD for constant c.">Cudd_addConst</a> <a class="el" href="cuddAPI_8c.html#aacea7b5ed8dc2595a1c0e01788bc205a" title="Returns a new ADD variable at a specified level.">Cudd_addNewVarAtLevel</a> </dd></dl>

</div>
</div>
<a id="ad77f4dd2911bac8e25633fe84c6cfb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77f4dd2911bac8e25633fe84c6cfb8b">&#9670;&nbsp;</a></span>Cudd_addNewVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addNewVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new ADD variable. </p>
<p>The new variable has an index equal to the largest previous index plus 1. An ADD variable differs from a BDD variable because it points to the arithmetic zero, instead of having a complement pointer to 1.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new variable if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a475c50e1a273569cc0ffc19ab98c28ce" title="Returns a new BDD variable.">Cudd_bddNewVar</a> <a class="el" href="cuddAPI_8c.html#a19967d7c87650f63fc312f38c318e3e9" title="Returns the ADD variable with index i.">Cudd_addIthVar</a> <a class="el" href="cuddAPI_8c.html#a8b8fb347b6c5324ef9bce64aa73a63bb" title="Returns the ADD for constant c.">Cudd_addConst</a> <a class="el" href="cuddAPI_8c.html#aacea7b5ed8dc2595a1c0e01788bc205a" title="Returns a new ADD variable at a specified level.">Cudd_addNewVarAtLevel</a> </dd></dl>

</div>
</div>
<a id="aacea7b5ed8dc2595a1c0e01788bc205a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacea7b5ed8dc2595a1c0e01788bc205a">&#9670;&nbsp;</a></span>Cudd_addNewVarAtLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addNewVarAtLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new ADD variable at a specified level. </p>
<p>The new variable has an index equal to the largest previous index plus 1 and is positioned at the specified level in the order.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new variable if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ad77f4dd2911bac8e25633fe84c6cfb8b" title="Returns a new ADD variable.">Cudd_addNewVar</a> <a class="el" href="cuddAPI_8c.html#a19967d7c87650f63fc312f38c318e3e9" title="Returns the ADD variable with index i.">Cudd_addIthVar</a> <a class="el" href="cuddAPI_8c.html#ae35eac7df807101795efe0d582ff05fa" title="Returns a new BDD variable at a specified level.">Cudd_bddNewVarAtLevel</a> </dd></dl>

</div>
</div>
<a id="affd2c1c2a110944c1d760de577aed431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd2c1c2a110944c1d760de577aed431">&#9670;&nbsp;</a></span>Cudd_AutodynDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_AutodynDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables automatic dynamic reordering. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a6a0d69b4288f36d5d377c460d49066a6" title="Enables automatic dynamic reordering of BDDs and ADDs.">Cudd_AutodynEnable</a> <a class="el" href="cuddAPI_8c.html#a3806c2327487b3cea3c7ffff75aead83" title="Reports the status of automatic dynamic reordering of BDDs and ADDs.">Cudd_ReorderingStatus</a> <a class="el" href="cuddAPI_8c.html#a219ccb201e3c1aa25ebef007399849fa" title="Disables automatic dynamic reordering of ZDDs.">Cudd_AutodynDisableZdd</a> </dd></dl>

</div>
</div>
<a id="a219ccb201e3c1aa25ebef007399849fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219ccb201e3c1aa25ebef007399849fa">&#9670;&nbsp;</a></span>Cudd_AutodynDisableZdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_AutodynDisableZdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables automatic dynamic reordering of ZDDs. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a709e0e15a38d6d6e9c83ff8b8a9d07f2" title="Enables automatic dynamic reordering of ZDDs.">Cudd_AutodynEnableZdd</a> <a class="el" href="cuddAPI_8c.html#ac6f65c44244489bfbb37137929baf0cd" title="Reports the status of automatic dynamic reordering of ZDDs.">Cudd_ReorderingStatusZdd</a> <a class="el" href="cuddAPI_8c.html#affd2c1c2a110944c1d760de577aed431" title="Disables automatic dynamic reordering.">Cudd_AutodynDisable</a> </dd></dl>

</div>
</div>
<a id="a6a0d69b4288f36d5d377c460d49066a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0d69b4288f36d5d377c460d49066a6">&#9670;&nbsp;</a></span>Cudd_AutodynEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_AutodynEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a>&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables automatic dynamic reordering of BDDs and ADDs. </p>
<p>Parameter method is used to determine the method used for reordering. If CUDD_REORDER_SAME is passed, the method is unchanged.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#affd2c1c2a110944c1d760de577aed431" title="Disables automatic dynamic reordering.">Cudd_AutodynDisable</a> <a class="el" href="cuddAPI_8c.html#a3806c2327487b3cea3c7ffff75aead83" title="Reports the status of automatic dynamic reordering of BDDs and ADDs.">Cudd_ReorderingStatus</a> <a class="el" href="cuddAPI_8c.html#a709e0e15a38d6d6e9c83ff8b8a9d07f2" title="Enables automatic dynamic reordering of ZDDs.">Cudd_AutodynEnableZdd</a> </dd></dl>

</div>
</div>
<a id="a709e0e15a38d6d6e9c83ff8b8a9d07f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a709e0e15a38d6d6e9c83ff8b8a9d07f2">&#9670;&nbsp;</a></span>Cudd_AutodynEnableZdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_AutodynEnableZdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a>&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables automatic dynamic reordering of ZDDs. </p>
<p>Parameter method is used to determine the method used for reordering ZDDs. If CUDD_REORDER_SAME is passed, the method is unchanged.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a219ccb201e3c1aa25ebef007399849fa" title="Disables automatic dynamic reordering of ZDDs.">Cudd_AutodynDisableZdd</a> <a class="el" href="cuddAPI_8c.html#ac6f65c44244489bfbb37137929baf0cd" title="Reports the status of automatic dynamic reordering of ZDDs.">Cudd_ReorderingStatusZdd</a> <a class="el" href="cuddAPI_8c.html#a6a0d69b4288f36d5d377c460d49066a6" title="Enables automatic dynamic reordering of BDDs and ADDs.">Cudd_AutodynEnable</a> </dd></dl>

</div>
</div>
<a id="a5acdc5b22c44f316a98c894998ca93d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acdc5b22c44f316a98c894998ca93d8">&#9670;&nbsp;</a></span>Cudd_bddBindVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddBindVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevents sifting of a variable. </p>
<p>This function sets a flag to prevent sifting of a variable.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise (i.e., invalid variable index).</dd></dl>
<dl class="section user"><dt>Side effects\n Changes the "bindVar" flag in DdSubtable.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a944f587db5ad4427ea36912313adccaa" title="Allows the sifting of a variable.">Cudd_bddUnbindVar</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">index</td><td>variable index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f4fca0bea12745bf32f153a72dc269f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4fca0bea12745bf32f153a72dc269f">&#9670;&nbsp;</a></span>Cudd_bddIsNsVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIsNsVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a variable is next state. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the variable's type is present state; 0 if the variable exists but is not a present state; -1 if the variable does not exist.</dd></dl>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a9259947e31d7d43fee7209e08e0257f0" title="Sets a variable type to next state.">Cudd_bddSetNsVar</a> <a class="el" href="cuddAPI_8c.html#a8807a8333099dbd0d32cccf9da8841b2" title="Checks whether a variable is primary input.">Cudd_bddIsPiVar</a> <a class="el" href="cuddAPI_8c.html#a390b021da58cb55e9c912f4490a5845e" title="Checks whether a variable is present state.">Cudd_bddIsPsVar</a> </dd></dl>

</div>
</div>
<a id="a8807a8333099dbd0d32cccf9da8841b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8807a8333099dbd0d32cccf9da8841b2">&#9670;&nbsp;</a></span>Cudd_bddIsPiVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIsPiVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a variable is primary input. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the variable's type is primary input; 0 if the variable exists but is not a primary input; -1 if the variable does not exist.</dd></dl>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aac6849dc17bbba2043922cb0efcd21ec" title="Sets a variable type to primary input.">Cudd_bddSetPiVar</a> <a class="el" href="cuddAPI_8c.html#a390b021da58cb55e9c912f4490a5845e" title="Checks whether a variable is present state.">Cudd_bddIsPsVar</a> <a class="el" href="cuddAPI_8c.html#a5f4fca0bea12745bf32f153a72dc269f" title="Checks whether a variable is next state.">Cudd_bddIsNsVar</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">index</td><td>variable index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a390b021da58cb55e9c912f4490a5845e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390b021da58cb55e9c912f4490a5845e">&#9670;&nbsp;</a></span>Cudd_bddIsPsVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIsPsVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a variable is present state. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the variable's type is present state; 0 if the variable exists but is not a present state; -1 if the variable does not exist.</dd></dl>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac8deaa5bc364ba47901043ea405b6909" title="Sets a variable type to present state.">Cudd_bddSetPsVar</a> <a class="el" href="cuddAPI_8c.html#a8807a8333099dbd0d32cccf9da8841b2" title="Checks whether a variable is primary input.">Cudd_bddIsPiVar</a> <a class="el" href="cuddAPI_8c.html#a5f4fca0bea12745bf32f153a72dc269f" title="Checks whether a variable is next state.">Cudd_bddIsNsVar</a> </dd></dl>

</div>
</div>
<a id="a7174f24036c4eae624311b273df978da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7174f24036c4eae624311b273df978da">&#9670;&nbsp;</a></span>Cudd_bddIsVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIsVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 1 if the given node is a BDD variable; 0 otherwise. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a14eda0885ab454e4e518639208e0c920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14eda0885ab454e4e518639208e0c920">&#9670;&nbsp;</a></span>Cudd_bddIsVarHardGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIsVarHardGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a variable is set to be in a hard group. </p>
<p>This function is used for lazy sifting.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the variable is marked to be in a hard group; 0 if the variable exists, but it is not marked to be in a hard group; -1 if the variable does not exist.</dd></dl>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2f3008fcc7c507d061c10a343a6c01ce" title="Sets a variable to be a hard group.">Cudd_bddSetVarHardGroup</a> </dd></dl>

</div>
</div>
<a id="a956ea07041f3e4f560bc936404461b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956ea07041f3e4f560bc936404461b2a">&#9670;&nbsp;</a></span>Cudd_bddIsVarToBeGrouped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIsVarToBeGrouped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a variable is set to be grouped. </p>
<p>This function is used for lazy sifting.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>

</div>
</div>
<a id="a8e0ef3b582414eb1907ad98fb4cc16e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0ef3b582414eb1907ad98fb4cc16e9">&#9670;&nbsp;</a></span>Cudd_bddIsVarToBeUngrouped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIsVarToBeUngrouped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a variable is set to be ungrouped. </p>
<p>This function is used for lazy sifting.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the variable is marked to be ungrouped; 0 if the variable exists, but it is not marked to be ungrouped; -1 if the variable does not exist.</dd></dl>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#acdd0386d3adadf96af5a95939586dc7b" title="Sets a variable to be ungrouped.">Cudd_bddSetVarToBeUngrouped</a> </dd></dl>

</div>
</div>
<a id="a40fd71665cde402bd5bc4f39015c09ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fd71665cde402bd5bc4f39015c09ae">&#9670;&nbsp;</a></span>Cudd_bddIthVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddIthVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the BDD variable with index i. </p>
<p>Retrieves the BDD variable with index i if it already exists, or creates a new BDD variable.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the variable if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a475c50e1a273569cc0ffc19ab98c28ce" title="Returns a new BDD variable.">Cudd_bddNewVar</a> <a class="el" href="cuddAPI_8c.html#a19967d7c87650f63fc312f38c318e3e9" title="Returns the ADD variable with index i.">Cudd_addIthVar</a> <a class="el" href="cuddAPI_8c.html#ae35eac7df807101795efe0d582ff05fa" title="Returns a new BDD variable at a specified level.">Cudd_bddNewVarAtLevel</a> <a class="el" href="cuddAPI_8c.html#a44d8f64c98953fd110d0e5146bcadaca" title="Returns the i-th element of the vars array.">Cudd_ReadVars</a> </dd></dl>

</div>
</div>
<a id="a475c50e1a273569cc0ffc19ab98c28ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475c50e1a273569cc0ffc19ab98c28ce">&#9670;&nbsp;</a></span>Cudd_bddNewVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddNewVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new BDD variable. </p>
<p>The new variable has an index equal to the largest previous index plus 1.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new variable if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ad77f4dd2911bac8e25633fe84c6cfb8b" title="Returns a new ADD variable.">Cudd_addNewVar</a> <a class="el" href="cuddAPI_8c.html#a40fd71665cde402bd5bc4f39015c09ae" title="Returns the BDD variable with index i.">Cudd_bddIthVar</a> <a class="el" href="cuddAPI_8c.html#ae35eac7df807101795efe0d582ff05fa" title="Returns a new BDD variable at a specified level.">Cudd_bddNewVarAtLevel</a> </dd></dl>

</div>
</div>
<a id="ae35eac7df807101795efe0d582ff05fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35eac7df807101795efe0d582ff05fa">&#9670;&nbsp;</a></span>Cudd_bddNewVarAtLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddNewVarAtLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new BDD variable at a specified level. </p>
<p>The new variable has an index equal to the largest previous index plus 1 and is positioned at the specified level in the order.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new variable if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a475c50e1a273569cc0ffc19ab98c28ce" title="Returns a new BDD variable.">Cudd_bddNewVar</a> <a class="el" href="cuddAPI_8c.html#a40fd71665cde402bd5bc4f39015c09ae" title="Returns the BDD variable with index i.">Cudd_bddIthVar</a> <a class="el" href="cuddAPI_8c.html#aacea7b5ed8dc2595a1c0e01788bc205a" title="Returns a new ADD variable at a specified level.">Cudd_addNewVarAtLevel</a> </dd></dl>

</div>
</div>
<a id="a642b76a558f6dafd89648f9f7c470b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642b76a558f6dafd89648f9f7c470b68">&#9670;&nbsp;</a></span>Cudd_bddReadPairIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddReadPairIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a corresponding pair index for a given index. </p>
<p>These pair indices are present and next state variable.</p>
<dl class="section return"><dt>Returns</dt><dd>the corresponding variable index if the variable exists; -1 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n modifies the manager</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac11beec034c2fc7842ca370aaeed9b21" title="Sets a corresponding pair index for a given index.">Cudd_bddSetPairIndex</a> </dd></dl>

</div>
</div>
<a id="a3eb093bdd80db0b880f61017f3e36de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb093bdd80db0b880f61017f3e36de2">&#9670;&nbsp;</a></span>Cudd_bddRealignDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_bddRealignDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables realignment of ZDD order to BDD order. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2d0d34d836668fc62e7c7835fa95132d" title="Enables realignment of BDD order to ZDD order.">Cudd_bddRealignEnable</a> <a class="el" href="cuddAPI_8c.html#a516183604a75b38337b81fd17c291826" title="Tells whether the realignment of BDD order to ZDD order is enabled.">Cudd_bddRealignmentEnabled</a> <a class="el" href="cuddAPI_8c.html#aa57aff1886a1fea0cb8b5bf8d66cf50e" title="Enables realignment of ZDD order to BDD order.">Cudd_zddRealignEnable</a> <a class="el" href="cuddAPI_8c.html#a34225975eef55170213a0a9efed5a891" title="Tells whether the realignment of ZDD order to BDD order is enabled.">Cudd_zddRealignmentEnabled</a> </dd></dl>

</div>
</div>
<a id="a2d0d34d836668fc62e7c7835fa95132d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0d34d836668fc62e7c7835fa95132d">&#9670;&nbsp;</a></span>Cudd_bddRealignEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_bddRealignEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables realignment of BDD order to ZDD order. </p>
<p>Enables realignment of the BDD variable order to the ZDD variable order after the ZDDs have been reordered. The number of ZDD variables must be a multiple of the number of BDD variables for realignment to make sense. If this condition is not met, Cudd_zddReduceHeap will return 0. Let <code>M</code> be the ratio of the two numbers. For the purpose of realignment, the ZDD variables from <code>M*i</code> to <code>(M+1)*i-1</code> are reagarded as corresponding to BDD variable <code>i</code>. Realignment is initially disabled.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddReord_8c.html#ab2a6a57fc8464e16e222c130aed593d9" title="Main dynamic reordering routine for ZDDs.">Cudd_zddReduceHeap</a> <a class="el" href="cuddAPI_8c.html#a3eb093bdd80db0b880f61017f3e36de2" title="Disables realignment of ZDD order to BDD order.">Cudd_bddRealignDisable</a> <a class="el" href="cuddAPI_8c.html#a516183604a75b38337b81fd17c291826" title="Tells whether the realignment of BDD order to ZDD order is enabled.">Cudd_bddRealignmentEnabled</a> <a class="el" href="cuddAPI_8c.html#afea01466660ca226539a66a014a4da00" title="Disables realignment of ZDD order to BDD order.">Cudd_zddRealignDisable</a> <a class="el" href="cuddAPI_8c.html#a34225975eef55170213a0a9efed5a891" title="Tells whether the realignment of ZDD order to BDD order is enabled.">Cudd_zddRealignmentEnabled</a> </dd></dl>

</div>
</div>
<a id="a516183604a75b38337b81fd17c291826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516183604a75b38337b81fd17c291826">&#9670;&nbsp;</a></span>Cudd_bddRealignmentEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddRealignmentEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether the realignment of BDD order to ZDD order is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the realignment of BDD order to ZDD order is enabled; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2d0d34d836668fc62e7c7835fa95132d" title="Enables realignment of BDD order to ZDD order.">Cudd_bddRealignEnable</a> <a class="el" href="cuddAPI_8c.html#a3eb093bdd80db0b880f61017f3e36de2" title="Disables realignment of ZDD order to BDD order.">Cudd_bddRealignDisable</a> <a class="el" href="cuddAPI_8c.html#aa57aff1886a1fea0cb8b5bf8d66cf50e" title="Enables realignment of ZDD order to BDD order.">Cudd_zddRealignEnable</a> <a class="el" href="cuddAPI_8c.html#afea01466660ca226539a66a014a4da00" title="Disables realignment of ZDD order to BDD order.">Cudd_zddRealignDisable</a> </dd></dl>

</div>
</div>
<a id="ac8613c4063493aebe3dc9e0e14562114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8613c4063493aebe3dc9e0e14562114">&#9670;&nbsp;</a></span>Cudd_bddResetVarToBeGrouped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddResetVarToBeGrouped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets a variable not to be grouped. </p>
<p>This function is used for lazy sifting.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n modifies the manager</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a776ff1149be00414f9dfb9d8e5236b6a" title="Sets a variable to be grouped.">Cudd_bddSetVarToBeGrouped</a> <a class="el" href="cuddAPI_8c.html#a2f3008fcc7c507d061c10a343a6c01ce" title="Sets a variable to be a hard group.">Cudd_bddSetVarHardGroup</a> </dd></dl>

</div>
</div>
<a id="a9259947e31d7d43fee7209e08e0257f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9259947e31d7d43fee7209e08e0257f0">&#9670;&nbsp;</a></span>Cudd_bddSetNsVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddSetNsVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a variable type to next state. </p>
<p>The variable type is used by lazy sifting.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n modifies the manager</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aac6849dc17bbba2043922cb0efcd21ec" title="Sets a variable type to primary input.">Cudd_bddSetPiVar</a> <a class="el" href="cuddAPI_8c.html#ac8deaa5bc364ba47901043ea405b6909" title="Sets a variable type to present state.">Cudd_bddSetPsVar</a> <a class="el" href="cuddAPI_8c.html#a5f4fca0bea12745bf32f153a72dc269f" title="Checks whether a variable is next state.">Cudd_bddIsNsVar</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">index</td><td>variable index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac11beec034c2fc7842ca370aaeed9b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11beec034c2fc7842ca370aaeed9b21">&#9670;&nbsp;</a></span>Cudd_bddSetPairIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddSetPairIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pairIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a corresponding pair index for a given index. </p>
<p>These pair indices are present and next state variable.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n modifies the manager</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a642b76a558f6dafd89648f9f7c470b68" title="Reads a corresponding pair index for a given index.">Cudd_bddReadPairIndex</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">index</td><td>variable index </td></tr>
    <tr><td class="paramname">pairIndex</td><td>corresponding variable index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac6849dc17bbba2043922cb0efcd21ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6849dc17bbba2043922cb0efcd21ec">&#9670;&nbsp;</a></span>Cudd_bddSetPiVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddSetPiVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a variable type to primary input. </p>
<p>The variable type is used by lazy sifting.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n modifies the manager</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac8deaa5bc364ba47901043ea405b6909" title="Sets a variable type to present state.">Cudd_bddSetPsVar</a> <a class="el" href="cuddAPI_8c.html#a9259947e31d7d43fee7209e08e0257f0" title="Sets a variable type to next state.">Cudd_bddSetNsVar</a> <a class="el" href="cuddAPI_8c.html#a8807a8333099dbd0d32cccf9da8841b2" title="Checks whether a variable is primary input.">Cudd_bddIsPiVar</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">index</td><td>variable index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8deaa5bc364ba47901043ea405b6909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8deaa5bc364ba47901043ea405b6909">&#9670;&nbsp;</a></span>Cudd_bddSetPsVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddSetPsVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a variable type to present state. </p>
<p>The variable type is used by lazy sifting.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n modifies the manager</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aac6849dc17bbba2043922cb0efcd21ec" title="Sets a variable type to primary input.">Cudd_bddSetPiVar</a> <a class="el" href="cuddAPI_8c.html#a9259947e31d7d43fee7209e08e0257f0" title="Sets a variable type to next state.">Cudd_bddSetNsVar</a> <a class="el" href="cuddAPI_8c.html#a390b021da58cb55e9c912f4490a5845e" title="Checks whether a variable is present state.">Cudd_bddIsPsVar</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">index</td><td>variable index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f3008fcc7c507d061c10a343a6c01ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3008fcc7c507d061c10a343a6c01ce">&#9670;&nbsp;</a></span>Cudd_bddSetVarHardGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddSetVarHardGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a variable to be a hard group. </p>
<p>This function is used for lazy sifting.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n modifies the manager</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a776ff1149be00414f9dfb9d8e5236b6a" title="Sets a variable to be grouped.">Cudd_bddSetVarToBeGrouped</a> <a class="el" href="cuddAPI_8c.html#ac8613c4063493aebe3dc9e0e14562114" title="Resets a variable not to be grouped.">Cudd_bddResetVarToBeGrouped</a> <a class="el" href="cuddAPI_8c.html#a14eda0885ab454e4e518639208e0c920" title="Checks whether a variable is set to be in a hard group.">Cudd_bddIsVarHardGroup</a> </dd></dl>

</div>
</div>
<a id="a776ff1149be00414f9dfb9d8e5236b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776ff1149be00414f9dfb9d8e5236b6a">&#9670;&nbsp;</a></span>Cudd_bddSetVarToBeGrouped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddSetVarToBeGrouped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a variable to be grouped. </p>
<p>This function is used for lazy sifting.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n modifies the manager</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2f3008fcc7c507d061c10a343a6c01ce" title="Sets a variable to be a hard group.">Cudd_bddSetVarHardGroup</a> <a class="el" href="cuddAPI_8c.html#ac8613c4063493aebe3dc9e0e14562114" title="Resets a variable not to be grouped.">Cudd_bddResetVarToBeGrouped</a> </dd></dl>

</div>
</div>
<a id="acdd0386d3adadf96af5a95939586dc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd0386d3adadf96af5a95939586dc7b">&#9670;&nbsp;</a></span>Cudd_bddSetVarToBeUngrouped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddSetVarToBeUngrouped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a variable to be ungrouped. </p>
<p>This function is used for lazy sifting.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n modifies the manager</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a8e0ef3b582414eb1907ad98fb4cc16e9" title="Checks whether a variable is set to be ungrouped.">Cudd_bddIsVarToBeUngrouped</a> </dd></dl>

</div>
</div>
<a id="a944f587db5ad4427ea36912313adccaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944f587db5ad4427ea36912313adccaa">&#9670;&nbsp;</a></span>Cudd_bddUnbindVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddUnbindVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the sifting of a variable. </p>
<p>This function resets the flag that prevents the sifting of a variable. In successive variable reorderings, the variable will NOT be skipped, that is, sifted. Initially all variables can be sifted. It is necessary to call this function only to re-enable sifting after a call to Cudd_bddBindVar.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise (i.e., invalid variable index).</dd></dl>
<dl class="section user"><dt>Side effects\n Changes the "bindVar" flag in DdSubtable.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a5acdc5b22c44f316a98c894998ca93d8" title="Prevents sifting of a variable.">Cudd_bddBindVar</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">index</td><td>variable index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88d01993b4162e8ece02e339ecb0a456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d01993b4162e8ece02e339ecb0a456">&#9670;&nbsp;</a></span>Cudd_bddVarIsBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddVarIsBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether a variable can be sifted. </p>
<p>This function returns 1 if a variable is enabled for sifting. Initially all variables can be sifted. This function returns 0 if there has been a previous call to Cudd_bddBindVar for that variable not followed by a call to Cudd_bddUnbindVar. The function returns 0 also in the case in which the index of the variable is out of bounds.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a5acdc5b22c44f316a98c894998ca93d8" title="Prevents sifting of a variable.">Cudd_bddBindVar</a> <a class="el" href="cuddAPI_8c.html#a944f587db5ad4427ea36912313adccaa" title="Allows the sifting of a variable.">Cudd_bddUnbindVar</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">index</td><td>variable index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed3a189c261ed9f698ace55ade32af01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3a189c261ed9f698ace55ade32af01">&#9670;&nbsp;</a></span>Cudd_ClearErrorCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_ClearErrorCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the error code of a manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a988b83058c815b1ca112c6a9c74525ad" title="Returns the code of the last error.">Cudd_ReadErrorCode</a> </dd></dl>

</div>
</div>
<a id="ae34d186620ce66627e57bbccfa24a892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34d186620ce66627e57bbccfa24a892">&#9670;&nbsp;</a></span>Cudd_DeadAreCounted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_DeadAreCounted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether dead nodes are counted towards triggering reordering. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if dead nodes are counted; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#af0b407453f68498df9b9783f88401cf5" title="Causes the dead nodes to be counted towards triggering reordering.">Cudd_TurnOnCountDead</a> <a class="el" href="cuddAPI_8c.html#a5b822894a35380ffca9e555286213484" title="Causes the dead nodes not to be counted towards triggering reordering.">Cudd_TurnOffCountDead</a> </dd></dl>

</div>
</div>
<a id="ab1def55437ab00e012fba1a98bc3a941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1def55437ab00e012fba1a98bc3a941">&#9670;&nbsp;</a></span>Cudd_DisableGarbageCollection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_DisableGarbageCollection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables garbage collection. </p>
<p>Garbage collection is initially enabled. This function may be called to disable it. However, garbage collection will still occur when a new node must be created and no memory is left, or when garbage collection is required for correctness. (E.g., before reordering.)</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a95a5511bcc805af71fc1fb5abba96f1e" title="Enables garbage collection.">Cudd_EnableGarbageCollection</a> <a class="el" href="cuddAPI_8c.html#adf441cdb56f24a9e3e20f6e87cc571c8" title="Tells whether garbage collection is enabled.">Cudd_GarbageCollectionEnabled</a> </dd></dl>

</div>
</div>
<a id="a1363eeb294a402d754f142c2022d4562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1363eeb294a402d754f142c2022d4562">&#9670;&nbsp;</a></span>Cudd_DisableOrderingMonitoring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_DisableOrderingMonitoring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables monitoring of ordering. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n Removes functions from the pre-reordering and post-reordering</dt><dd>hooks.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a6aa547783b2cd3e54062864543fba0de" title="Enables monitoring of ordering.">Cudd_EnableOrderingMonitoring</a> </dd></dl>

</div>
</div>
<a id="a249298e38710246ab1ead014cfe54dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249298e38710246ab1ead014cfe54dd9">&#9670;&nbsp;</a></span>Cudd_DisableReorderingReporting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_DisableReorderingReporting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables reporting of reordering stats. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n Removes functions from the pre-reordering and post-reordering</dt><dd>hooks.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#adfe5374e85cf3fb0827307b1e3cc5e07" title="Enables reporting of reordering stats.">Cudd_EnableReorderingReporting</a> <a class="el" href="cuddAPI_8c.html#a4a634a339969d6d84e3db858f3f77be4" title="Returns 1 if reporting of reordering stats is enabled; 0 otherwise.">Cudd_ReorderingReporting</a> </dd></dl>

</div>
</div>
<a id="a601a736699b3e5c8eb7149e6049ea131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601a736699b3e5c8eb7149e6049ea131">&#9670;&nbsp;</a></span>Cudd_E()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_E </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the else child of an internal node. </p>
<p>If <code>node</code> is a constant node, the result is unpredictable.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aeed52f5319f877acc6ac7c27490111b6" title="Returns the then child of an internal node.">Cudd_T</a> <a class="el" href="cuddAPI_8c.html#a9ebe62ac5ac8a49dc13bce839ae09c88" title="Returns the value of a constant node.">Cudd_V</a> </dd></dl>

</div>
</div>
<a id="a95a5511bcc805af71fc1fb5abba96f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a5511bcc805af71fc1fb5abba96f1e">&#9670;&nbsp;</a></span>Cudd_EnableGarbageCollection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_EnableGarbageCollection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables garbage collection. </p>
<p>Garbage collection is initially enabled. Therefore it is necessary to call this function only if garbage collection has been explicitly disabled.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ab1def55437ab00e012fba1a98bc3a941" title="Disables garbage collection.">Cudd_DisableGarbageCollection</a> <a class="el" href="cuddAPI_8c.html#adf441cdb56f24a9e3e20f6e87cc571c8" title="Tells whether garbage collection is enabled.">Cudd_GarbageCollectionEnabled</a> </dd></dl>

</div>
</div>
<a id="a6aa547783b2cd3e54062864543fba0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa547783b2cd3e54062864543fba0de">&#9670;&nbsp;</a></span>Cudd_EnableOrderingMonitoring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_EnableOrderingMonitoring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables monitoring of ordering. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n Installs functions in the pre-reordering and post-reordering</dt><dd>hooks.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#adfe5374e85cf3fb0827307b1e3cc5e07" title="Enables reporting of reordering stats.">Cudd_EnableReorderingReporting</a> </dd></dl>

</div>
</div>
<a id="adfe5374e85cf3fb0827307b1e3cc5e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe5374e85cf3fb0827307b1e3cc5e07">&#9670;&nbsp;</a></span>Cudd_EnableReorderingReporting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_EnableReorderingReporting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables reporting of reordering stats. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n Installs functions in the pre-reordering and post-reordering</dt><dd>hooks.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a249298e38710246ab1ead014cfe54dd9" title="Disables reporting of reordering stats.">Cudd_DisableReorderingReporting</a> <a class="el" href="cuddAPI_8c.html#a4a634a339969d6d84e3db858f3f77be4" title="Returns 1 if reporting of reordering stats is enabled; 0 otherwise.">Cudd_ReorderingReporting</a> </dd></dl>

</div>
</div>
<a id="a31d06c2608e7c5b08b3fd6c6e200662f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d06c2608e7c5b08b3fd6c6e200662f">&#9670;&nbsp;</a></span>Cudd_ExpectedUsedSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ExpectedUsedSlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the expected fraction of used slots in the unique table. </p>
<p>This expected value is based on the assumption that the hash function distributes the keys randomly; it can be compared with the result of Cudd_ReadUsedSlots to monitor the performance of the unique table hash function.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a3787560300153655851b4fe3c7646b0c" title="Returns the total number of slots of the unique table.">Cudd_ReadSlots</a> <a class="el" href="cuddAPI_8c.html#a0941cb7338ba1a71f3451f4c2a747093" title="Reads the fraction of used slots in the unique table.">Cudd_ReadUsedSlots</a> </dd></dl>

</div>
</div>
<a id="af5c6ecb39244a6db49494d1f1e31bd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c6ecb39244a6db49494d1f1e31bd1a">&#9670;&nbsp;</a></span>Cudd_FreeTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_FreeTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the variable group tree of the manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2aa3827dfffcc29254520628b15aab55" title="Sets the variable group tree of the manager.">Cudd_SetTree</a> <a class="el" href="cuddAPI_8c.html#a6ee8468f5b7fe67a0f609412e211632b" title="Returns the variable group tree of the manager.">Cudd_ReadTree</a> <a class="el" href="cuddAPI_8c.html#ac9a25622e38ad302c050803d520f5fce" title="Frees the variable group tree of the manager.">Cudd_FreeZddTree</a> </dd></dl>

</div>
</div>
<a id="ac9a25622e38ad302c050803d520f5fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a25622e38ad302c050803d520f5fce">&#9670;&nbsp;</a></span>Cudd_FreeZddTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_FreeZddTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the variable group tree of the manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2cdbbc9e78a4f0684a118f304eb1a455" title="Sets the ZDD variable group tree of the manager.">Cudd_SetZddTree</a> <a class="el" href="cuddAPI_8c.html#ad3d3dbe0fa509a7f70691dcb6d8726ad" title="Returns the variable group tree of the manager.">Cudd_ReadZddTree</a> <a class="el" href="cuddAPI_8c.html#af5c6ecb39244a6db49494d1f1e31bd1a" title="Frees the variable group tree of the manager.">Cudd_FreeTree</a> </dd></dl>

</div>
</div>
<a id="adf441cdb56f24a9e3e20f6e87cc571c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf441cdb56f24a9e3e20f6e87cc571c8">&#9670;&nbsp;</a></span>Cudd_GarbageCollectionEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_GarbageCollectionEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether garbage collection is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if garbage collection is enabled; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a95a5511bcc805af71fc1fb5abba96f1e" title="Enables garbage collection.">Cudd_EnableGarbageCollection</a> <a class="el" href="cuddAPI_8c.html#ab1def55437ab00e012fba1a98bc3a941" title="Disables garbage collection.">Cudd_DisableGarbageCollection</a> </dd></dl>

</div>
</div>
<a id="a333169d352f3ab54002eaae738a39d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333169d352f3ab54002eaae738a39d68">&#9670;&nbsp;</a></span>Cudd_IncreaseTimeLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_IncreaseTimeLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>increase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases the time limit for the manager. </p>
<p>The time increase must be expressed in milliseconds.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a855a253235b54ff16fd66c6e43241069" title="Returns the time limit for the manager.">Cudd_ReadTimeLimit</a> <a class="el" href="cuddAPI_8c.html#ac6e694e133632d34256646869f076ff5" title="Sets the time limit for the manager.">Cudd_SetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aa497c8cb498833021f18813fb5813b57" title="Unsets the time limit for the manager.">Cudd_UnsetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aeeb6240810097270fd1414536de17eb0" title="Updates the time limit for the manager.">Cudd_UpdateTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a7c3b2370790803f37aace1dfc0a7d1cc" title="Returns true if the time limit for the manager is set.">Cudd_TimeLimited</a> <a class="el" href="cuddAPI_8c.html#a2b42ab1fa12990140dbfd415bc7a6231" title="Sets the start time of the manager.">Cudd_SetStartTime</a> </dd></dl>

</div>
</div>
<a id="a8941f373e5e1156b2e42af09f4247d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8941f373e5e1156b2e42af09f4247d47">&#9670;&nbsp;</a></span>Cudd_InstallOutOfMemoryHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#ab7b4676c7e2dd36567b3749740ca8b60">DD_OOMFP</a> Cudd_InstallOutOfMemoryHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#ab7b4676c7e2dd36567b3749740ca8b60">DD_OOMFP</a>&#160;</td>
          <td class="paramname"><em>newHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs a handler for failed memory allocations. </p>
<p>Changing the handler only has an effect if the wrappers in <a class="el" href="safe__mem_8c.html" title="Interface routines to be placed between a program and the system memory allocator.">safe_mem.c</a> are in use.</p>
<dl class="section return"><dt>Returns</dt><dd>the current handler. </dd></dl>

</div>
</div>
<a id="a018bdc54a42aacf14959f83cbf6992b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018bdc54a42aacf14959f83cbf6992b6">&#9670;&nbsp;</a></span>Cudd_IsConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_IsConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 1 if the node is a constant node. </p>
<p>A constant node is not an internal node. The pointer passed to Cudd_IsConstant may be either regular or complemented.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>

</div>
</div>
<a id="a55eb04332db0a87f173b7638080ec856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55eb04332db0a87f173b7638080ec856">&#9670;&nbsp;</a></span>Cudd_IsInHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_IsInHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a1a0b162633be038685ce87dac7a57382">DD_HFP</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#afbec19daded82939f6045c92b3a7bde2">Cudd_HookType</a>&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a function is in a hook. </p>
<p>A hook is a list of application-provided functions called on certain occasions by the package.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the function is found; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a6884f064de544463f006f9104e4afa74" title="Adds a function to a hook.">Cudd_AddHook</a> <a class="el" href="cuddAPI_8c.html#a0c732be4af510054662cd6e6f0a5772f" title="Removes a function from a hook.">Cudd_RemoveHook</a> </dd></dl>

</div>
</div>
<a id="a4ac0cf7ba2eba7a6652a886deb4723fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac0cf7ba2eba7a6652a886deb4723fa">&#9670;&nbsp;</a></span>Cudd_IsNonConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_IsNonConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 1 if a DD node is not constant. </p>
<p>This function is useful to test the results of Cudd_bddIteConstant, Cudd_addIteConstant, Cudd_addEvalConst. These results may be a special value signifying non-constant. In the other cases Cudd_IsConstant can be used.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a018bdc54a42aacf14959f83cbf6992b6" title="Returns 1 if the node is a constant node.">Cudd_IsConstant</a> <a class="el" href="cuddBddIte_8c.html#ae893c6ab0472d7058bd424d02bc9420f" title="Implements ITEconstant(f,g,h).">Cudd_bddIteConstant</a> <a class="el" href="cuddAddIte_8c.html#ad1eae04162ef0a94b49121add887ee99" title="Implements ITEconstant for ADDs.">Cudd_addIteConstant</a> <a class="el" href="cuddAddIte_8c.html#a88cac595be91f0524a8be01c2b330661" title="Checks whether ADD g is constant whenever ADD f is 1.">Cudd_addEvalConst</a> </dd></dl>

</div>
</div>
<a id="a53c38a74f4362bd57bcb44593a3f515d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c38a74f4362bd57bcb44593a3f515d">&#9670;&nbsp;</a></span>Cudd_NodeReadIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_NodeReadIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the node. </p>
<p>The node pointer can be either regular or complemented.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#a2c0122cc772ed6f3012bcac42fac0c0c" title="Returns the current position in the order of variable index.">Cudd_ReadIndex</a> </dd></dl>

</div>
</div>
<a id="a93d721c40b8c47401a0739027cf5a571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d721c40b8c47401a0739027cf5a571">&#9670;&nbsp;</a></span>Cudd_OrderingMonitoring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_OrderingMonitoring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 1 if monitoring of ordering is enabled; 0 otherwise. </p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a6aa547783b2cd3e54062864543fba0de" title="Enables monitoring of ordering.">Cudd_EnableOrderingMonitoring</a> <a class="el" href="cuddAPI_8c.html#a1363eeb294a402d754f142c2022d4562" title="Disables monitoring of ordering.">Cudd_DisableOrderingMonitoring</a> </dd></dl>

</div>
</div>
<a id="aba970524139c009227b2fa0fc8cac0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba970524139c009227b2fa0fc8cac0eb">&#9670;&nbsp;</a></span>Cudd_PrintGroupedOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_PrintGroupedOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hook function to print the current variable order. </p>
<p>It may be called before or after reordering. Prints on the manager's stdout a parenthesized list that describes the variable groups.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a852da7502c07042fde873b504aaa4573" title="Sample hook function to call before reordering.">Cudd_StdPreReordHook</a> </dd></dl>

</div>
</div>
<a id="a0883e74086d9f61c2988ba614e9e649e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0883e74086d9f61c2988ba614e9e649e">&#9670;&nbsp;</a></span>Cudd_PrintInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_PrintInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints out statistics and settings for a CUDD manager. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a9f98975109e7d3afd1bad0716e4d6666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f98975109e7d3afd1bad0716e4d6666">&#9670;&nbsp;</a></span>Cudd_ReadApplicationHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Cudd_ReadApplicationHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the application hook. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2d4a097e769d11868f760b920e6f1da8" title="Sets the application hook.">Cudd_SetApplicationHook</a> </dd></dl>

</div>
</div>
<a id="a89117a52be055c338311b1380d511375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89117a52be055c338311b1380d511375">&#9670;&nbsp;</a></span>Cudd_ReadArcviolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadArcviolation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current value of the arcviolation parameter used in group sifting. </p>
<p>This parameter is used to decide how many arcs into <code>y</code> not coming from <code>x</code> are tolerable when checking for aggregation due to extended symmetry. The value should be between 0 and 100. A small value causes fewer variables to be aggregated. The default value is 0.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a3064405f352a9d93a6ee16cfa5d2512c" title="Sets the value of the arcviolation parameter used in group sifting.">Cudd_SetArcviolation</a> </dd></dl>

</div>
</div>
<a id="a041d561f9d388a943104665fe0c850c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041d561f9d388a943104665fe0c850c0">&#9670;&nbsp;</a></span>Cudd_ReadBackground()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ReadBackground </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the background constant of the manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a2281582d99df044cf8892204026b64b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2281582d99df044cf8892204026b64b9">&#9670;&nbsp;</a></span>Cudd_ReadCacheHits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadCacheHits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of cache hits. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ab4595bfefe543b3f8f74248c048b53fe" title="Returns the number of cache look-ups.">Cudd_ReadCacheLookUps</a> </dd></dl>

</div>
</div>
<a id="ab4595bfefe543b3f8f74248c048b53fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4595bfefe543b3f8f74248c048b53fe">&#9670;&nbsp;</a></span>Cudd_ReadCacheLookUps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadCacheLookUps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of cache look-ups. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2281582d99df044cf8892204026b64b9" title="Returns the number of cache hits.">Cudd_ReadCacheHits</a> </dd></dl>

</div>
</div>
<a id="ab588943f358faadd3c7e8a4caf813fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab588943f358faadd3c7e8a4caf813fce">&#9670;&nbsp;</a></span>Cudd_ReadCacheSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadCacheSlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the number of slots in the cache. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aac309a335487dbb3ba77b088c90e085c" title="Reads the fraction of used slots in the cache.">Cudd_ReadCacheUsedSlots</a> </dd></dl>

</div>
</div>
<a id="aac309a335487dbb3ba77b088c90e085c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac309a335487dbb3ba77b088c90e085c">&#9670;&nbsp;</a></span>Cudd_ReadCacheUsedSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadCacheUsedSlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the fraction of used slots in the cache. </p>
<p>The unused slots are those in which no valid data is stored. Garbage collection, variable reordering, and cache resizing may cause used slots to become unused.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ab588943f358faadd3c7e8a4caf813fce" title="Reads the number of slots in the cache.">Cudd_ReadCacheSlots</a> </dd></dl>

</div>
</div>
<a id="a4074f697e7ea725a1b853d9a468a082e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4074f697e7ea725a1b853d9a468a082e">&#9670;&nbsp;</a></span>Cudd_ReadDead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of dead nodes in the unique table. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a5bc6805752cf0bc83080322d778759e6" title="Returns the number of nodes in the unique table.">Cudd_ReadKeys</a> </dd></dl>

</div>
</div>
<a id="ab6cafb71c46dedb3eaa27acd56b855b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cafb71c46dedb3eaa27acd56b855b8">&#9670;&nbsp;</a></span>Cudd_ReadElapsedTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Cudd_ReadElapsedTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the time elapsed since the start time of the manager. </p>
<p>The time is expressed in milliseconds.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ae94781bf6e62d0c6a3439b4db11b50e5" title="Returns the start time of the manager.">Cudd_ReadStartTime</a> <a class="el" href="cuddAPI_8c.html#a2b42ab1fa12990140dbfd415bc7a6231" title="Sets the start time of the manager.">Cudd_SetStartTime</a> </dd></dl>

</div>
</div>
<a id="ac711d8ce9d243e16246b83e3c1f04199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac711d8ce9d243e16246b83e3c1f04199">&#9670;&nbsp;</a></span>Cudd_ReadEpsilon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> Cudd_ReadEpsilon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the epsilon parameter of the manager. </p>
<p>The epsilon parameter control the comparison between floating point numbers.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a30ef132c1f56bdb0e26efc81fa695cf3" title="Sets the epsilon parameter of the manager to ep.">Cudd_SetEpsilon</a> </dd></dl>

</div>
</div>
<a id="a988b83058c815b1ca112c6a9c74525ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988b83058c815b1ca112c6a9c74525ad">&#9670;&nbsp;</a></span>Cudd_ReadErrorCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#a27114b4342bc1b987f35d751eae2444b">Cudd_ErrorType</a> Cudd_ReadErrorCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the code of the last error. </p>
<p>The error codes are defined in <a class="el" href="cudd_8h.html" title="The University of Colorado decision diagram package.">cudd.h</a>.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aed3a189c261ed9f698ace55ade32af01" title="Clear the error code of a manager.">Cudd_ClearErrorCode</a> </dd></dl>

</div>
</div>
<a id="a50aaebdd320041ddca11fdb0f3414f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50aaebdd320041ddca11fdb0f3414f0c">&#9670;&nbsp;</a></span>Cudd_ReadGarbageCollections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadGarbageCollections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of times garbage collection has occurred. </p>
<p>The number includes both the calls from reordering procedures and those caused by requests to create new nodes.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a653fa9231b3d68947521175de74f26b8" title="Returns the time spent in garbage collection.">Cudd_ReadGarbageCollectionTime</a> </dd></dl>

</div>
</div>
<a id="a653fa9231b3d68947521175de74f26b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653fa9231b3d68947521175de74f26b8">&#9670;&nbsp;</a></span>Cudd_ReadGarbageCollectionTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Cudd_ReadGarbageCollectionTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the time spent in garbage collection. </p>
<p>Returns the number of milliseconds spent doing garbage collection since the manager was initialized.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a50aaebdd320041ddca11fdb0f3414f0c" title="Returns the number of times garbage collection has occurred.">Cudd_ReadGarbageCollections</a> </dd></dl>

</div>
</div>
<a id="a8f2639c79f7b9c58367cbfc0f55ca3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2639c79f7b9c58367cbfc0f55ca3b5">&#9670;&nbsp;</a></span>Cudd_ReadGroupcheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#a8b2572b778b7e8bd68afcd4aa1f0ce33">Cudd_AggregationType</a> Cudd_ReadGroupcheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the groupcheck parameter of the manager. </p>
<p>The groupcheck parameter determines the aggregation criterion in group sifting.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aee7e7fa94656ed131aa67ca1ea15a031" title="Sets the parameter groupcheck of the manager to gc.">Cudd_SetGroupcheck</a> </dd></dl>

</div>
</div>
<a id="ae16ce73ed2e5afcd0dd1c1db43884d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16ce73ed2e5afcd0dd1c1db43884d2a">&#9670;&nbsp;</a></span>Cudd_ReadInvPerm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadInvPerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the variable currently in the i-th position of the order. </p>
<p>If the index is CUDD_CONST_INDEX, returns CUDD_CONST_INDEX; otherwise, if the index is out of bounds returns -1.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aacfa59899b792c9f47a612ceba42c976" title="Returns the current position of the i-th variable in the order.">Cudd_ReadPerm</a> <a class="el" href="cuddAPI_8c.html#a30f47219044e26a1be7699014dcc021a" title="Returns the index of the ZDD variable currently in the i-th position of the order.">Cudd_ReadInvPermZdd</a> </dd></dl>

</div>
</div>
<a id="a30f47219044e26a1be7699014dcc021a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f47219044e26a1be7699014dcc021a">&#9670;&nbsp;</a></span>Cudd_ReadInvPermZdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadInvPermZdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the ZDD variable currently in the i-th position of the order. </p>
<p>If the index is CUDD_CONST_INDEX, returns CUDD_CONST_INDEX; otherwise, if the index is out of bounds returns -1.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aacfa59899b792c9f47a612ceba42c976" title="Returns the current position of the i-th variable in the order.">Cudd_ReadPerm</a> <a class="el" href="cuddAPI_8c.html#a30f47219044e26a1be7699014dcc021a" title="Returns the index of the ZDD variable currently in the i-th position of the order.">Cudd_ReadInvPermZdd</a> </dd></dl>

</div>
</div>
<a id="a5bc6805752cf0bc83080322d778759e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc6805752cf0bc83080322d778759e6">&#9670;&nbsp;</a></span>Cudd_ReadKeys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadKeys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of nodes in the unique table. </p>
<p>Returns the total number of nodes currently in the unique table, including the dead nodes.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a4074f697e7ea725a1b853d9a468a082e" title="Returns the number of dead nodes in the unique table.">Cudd_ReadDead</a> </dd></dl>

</div>
</div>
<a id="a1dd42d8cb5c86659170103a3068e13a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd42d8cb5c86659170103a3068e13a6">&#9670;&nbsp;</a></span>Cudd_ReadLogicZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ReadLogicZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the logic zero constant of the manager. </p>
<p>The logic zero constant is the complement of the one constant, and is distinct from the arithmetic zero.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2651c953d81570d3f4f794bcbef40afe" title="Returns the one constant of the manager.">Cudd_ReadOne</a> <a class="el" href="cuddAPI_8c.html#a92900f3320df460a72eacc4ed801d69e" title="Returns the zero constant of the manager.">Cudd_ReadZero</a> </dd></dl>

</div>
</div>
<a id="ab452b9f1bbcdb8bf49cbea25f6e8ed8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab452b9f1bbcdb8bf49cbea25f6e8ed8d">&#9670;&nbsp;</a></span>Cudd_ReadLooseUpTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadLooseUpTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the looseUpTo parameter of the manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a1952bb97db9782bcf607d169c842b7ce" title="Sets the looseUpTo parameter of the manager.">Cudd_SetLooseUpTo</a> <a class="el" href="cuddAPI_8c.html#a79695ef1e6f821d310f5613a6d8ba148" title="Reads the hit rate that causes resizinig of the computed table.">Cudd_ReadMinHit</a> <a class="el" href="cuddAPI_8c.html#ace82092e4e785b388c83f554daa23283" title="Reads the minDead parameter of the manager.">Cudd_ReadMinDead</a> </dd></dl>

</div>
</div>
<a id="a7dafbaafff7055890cce20fa791b2092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dafbaafff7055890cce20fa791b2092">&#9670;&nbsp;</a></span>Cudd_ReadMaxCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadMaxCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the soft limit for the cache size. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#acfac0e32bb4bcfe7f0035f4fff401a0e" title="Reads the maxCacheHard parameter of the manager.">Cudd_ReadMaxCacheHard</a> </dd></dl>

</div>
</div>
<a id="acfac0e32bb4bcfe7f0035f4fff401a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfac0e32bb4bcfe7f0035f4fff401a0e">&#9670;&nbsp;</a></span>Cudd_ReadMaxCacheHard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadMaxCacheHard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the maxCacheHard parameter of the manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a4ced83212c4c45f94d8957e3fab485c5" title="Sets the maxCacheHard parameter of the manager.">Cudd_SetMaxCacheHard</a> <a class="el" href="cuddAPI_8c.html#a7dafbaafff7055890cce20fa791b2092" title="Returns the soft limit for the cache size.">Cudd_ReadMaxCache</a> </dd></dl>

</div>
</div>
<a id="a23f3600540de47d20e85eb4036af6e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f3600540de47d20e85eb4036af6e49">&#9670;&nbsp;</a></span>Cudd_ReadMaxGrowth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadMaxGrowth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the maxGrowth parameter of the manager. </p>
<p>This parameter determines how much the number of nodes can grow during sifting of a variable. Overall, sifting never increases the size of the decision diagrams. This parameter only refers to intermediate results. A lower value will speed up sifting, possibly at the expense of quality.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aa3a621a6133ce4203b8bfa351d5de4ea" title="Sets the maxGrowth parameter of the manager.">Cudd_SetMaxGrowth</a> <a class="el" href="cuddAPI_8c.html#a692abb5fde2011b2a3cec010946eebca" title="Reads the maxGrowthAlt parameter of the manager.">Cudd_ReadMaxGrowthAlternate</a> </dd></dl>

</div>
</div>
<a id="a692abb5fde2011b2a3cec010946eebca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692abb5fde2011b2a3cec010946eebca">&#9670;&nbsp;</a></span>Cudd_ReadMaxGrowthAlternate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadMaxGrowthAlternate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the maxGrowthAlt parameter of the manager. </p>
<p>This parameter is analogous to the maxGrowth paramter, and is used every given number of reorderings instead of maxGrowth. The number of reorderings is set with Cudd_SetReorderingCycle. If the number of reorderings is 0 (default) maxGrowthAlt is never used.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a23f3600540de47d20e85eb4036af6e49" title="Reads the maxGrowth parameter of the manager.">Cudd_ReadMaxGrowth</a> <a class="el" href="cuddAPI_8c.html#a7d4358c1f00a31b657c937b8e64ec6e6" title="Sets the maxGrowthAlt parameter of the manager.">Cudd_SetMaxGrowthAlternate</a> <a class="el" href="cuddAPI_8c.html#afd23a86c046d74935d746757846d1148" title="Sets the reordCycle parameter of the manager.">Cudd_SetReorderingCycle</a> <a class="el" href="cuddAPI_8c.html#aa5283d665223378e10425342dad1684b" title="Reads the reordCycle parameter of the manager.">Cudd_ReadReorderingCycle</a> </dd></dl>

</div>
</div>
<a id="a1dbe3503e24e823a81bc2c8acb065345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbe3503e24e823a81bc2c8acb065345">&#9670;&nbsp;</a></span>Cudd_ReadMaxIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadMaxIndex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum possible index for a variable. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="af6afbdb9c3955275888ec9cb60711a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6afbdb9c3955275888ec9cb60711a57">&#9670;&nbsp;</a></span>Cudd_ReadMaxLive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadMaxLive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the maximum allowed number of live nodes. </p>
<p>When this number is exceeded, the package returns NULL.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac553f7975b60ebe4a38141cbff1eebea" title="Sets the maximum allowed number of live nodes.">Cudd_SetMaxLive</a> </dd></dl>

</div>
</div>
<a id="aef52798a6b7994a3038335d36ec9f051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef52798a6b7994a3038335d36ec9f051">&#9670;&nbsp;</a></span>Cudd_ReadMaxMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Cudd_ReadMaxMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the maximum allowed memory. </p>
<p>When this number is exceeded, the package returns NULL.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a0d15a525874908e9230881bccabbb993" title="Sets the maximum allowed memory.">Cudd_SetMaxMemory</a> </dd></dl>

</div>
</div>
<a id="ad011aad1e779f0e31ab67cf7a1d7f591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad011aad1e779f0e31ab67cf7a1d7f591">&#9670;&nbsp;</a></span>Cudd_ReadMaxReorderings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadMaxReorderings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum number of times reordering may be invoked. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac22056db7260493748eda0162431cd76" title="Returns the number of times reordering has occurred.">Cudd_ReadReorderings</a> <a class="el" href="cuddAPI_8c.html#a3a2e39aeebc215847d374a01bb1f182b" title="Sets the maximum number of times reordering may be invoked.">Cudd_SetMaxReorderings</a> <a class="el" href="cuddReorder_8c.html#a02a5a86dfb8ebc7726d6cf56b6a7eec1" title="Main dynamic reordering routine.">Cudd_ReduceHeap</a> </dd></dl>

</div>
</div>
<a id="a952c97ec2d8b0a73f759e7e993e1e367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952c97ec2d8b0a73f759e7e993e1e367">&#9670;&nbsp;</a></span>Cudd_ReadMemoryInUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Cudd_ReadMemoryInUse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the memory in use by the manager measured in bytes. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="ace82092e4e785b388c83f554daa23283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace82092e4e785b388c83f554daa23283">&#9670;&nbsp;</a></span>Cudd_ReadMinDead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadMinDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the minDead parameter of the manager. </p>
<p>The minDead parameter is used by the package to decide whether to collect garbage or resize a subtable of the unique table when the subtable becomes too full. The application can indirectly control the value of minDead by setting the looseUpTo parameter.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a4074f697e7ea725a1b853d9a468a082e" title="Returns the number of dead nodes in the unique table.">Cudd_ReadDead</a> <a class="el" href="cuddAPI_8c.html#ab452b9f1bbcdb8bf49cbea25f6e8ed8d" title="Reads the looseUpTo parameter of the manager.">Cudd_ReadLooseUpTo</a> <a class="el" href="cuddAPI_8c.html#a1952bb97db9782bcf607d169c842b7ce" title="Sets the looseUpTo parameter of the manager.">Cudd_SetLooseUpTo</a> </dd></dl>

</div>
</div>
<a id="a79695ef1e6f821d310f5613a6d8ba148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79695ef1e6f821d310f5613a6d8ba148">&#9670;&nbsp;</a></span>Cudd_ReadMinHit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadMinHit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the hit rate that causes resizinig of the computed table. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ae96f3e2036a77ab8c1318e607dea232b" title="Sets the hit rate that causes resizinig of the computed table.">Cudd_SetMinHit</a> </dd></dl>

</div>
</div>
<a id="ae0ff7f850bf0b84af8ea0779ec0800ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ff7f850bf0b84af8ea0779ec0800ac">&#9670;&nbsp;</a></span>Cudd_ReadMinusInfinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ReadMinusInfinity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the minus-infinity constant from the manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="adc3820fb326bce09797fda8439b5daa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3820fb326bce09797fda8439b5daa4">&#9670;&nbsp;</a></span>Cudd_ReadNextReordering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadNextReordering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the threshold for the next dynamic reordering. </p>
<p>The threshold is in terms of number of nodes and is in effect only if reordering is enabled. The count does not include the dead nodes, unless the countDead parameter of the manager has been changed from its default setting.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a3d62c965eabd4ec777af47acd790ee47" title="Sets the threshold for the next dynamic reordering.">Cudd_SetNextReordering</a> </dd></dl>

</div>
</div>
<a id="a9ba2c88b8f70df51791c26ffde800fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba2c88b8f70df51791c26ffde800fc7">&#9670;&nbsp;</a></span>Cudd_ReadNodeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Cudd_ReadNodeCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the number of nodes in BDDs and ADDs. </p>
<p>This number does not include the isolated projection functions and the unused constants. These nodes that are not counted are not part of the DDs manipulated by the application.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a39633df05be731b6b145d65f83aed572" title="Reports the peak number of nodes.">Cudd_ReadPeakNodeCount</a> <a class="el" href="cuddAPI_8c.html#a4c015c746d9c71fb9b57249f2a4ccd72" title="Reports the number of nodes in ZDDs.">Cudd_zddReadNodeCount</a> </dd></dl>

</div>
</div>
<a id="ae7e283a368a08c5ac96101ee7e9b525c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e283a368a08c5ac96101ee7e9b525c">&#9670;&nbsp;</a></span>Cudd_ReadNodesDropped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadNodesDropped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of nodes dropped. </p>
<p>Returns the number of nodes killed by dereferencing if the keeping of this statistic is enabled; -1 otherwise. This statistic is enabled only if the package is compiled with DD_STATS defined.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#af525911b0006fddcbcf698a077b874cb" title="Returns the number of nodes freed.">Cudd_ReadNodesFreed</a> </dd></dl>

</div>
</div>
<a id="af525911b0006fddcbcf698a077b874cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af525911b0006fddcbcf698a077b874cb">&#9670;&nbsp;</a></span>Cudd_ReadNodesFreed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadNodesFreed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of nodes freed. </p>
<p>Returns the number of nodes returned to the free list if the keeping of this statistic is enabled; -1 otherwise. This statistic is enabled only if the package is compiled with DD_STATS defined.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ae7e283a368a08c5ac96101ee7e9b525c" title="Returns the number of nodes dropped.">Cudd_ReadNodesDropped</a> </dd></dl>

</div>
</div>
<a id="a2609fe9051be1a8ab6d305d38bfb5956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2609fe9051be1a8ab6d305d38bfb5956">&#9670;&nbsp;</a></span>Cudd_ReadNumberXovers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadNumberXovers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the current number of crossovers used by the genetic algorithm for variable reordering. </p>
<p>A larger number of crossovers will cause the genetic algorithm to take more time, but will generally produce better results. The default value is 0, in which case the package uses three times the number of variables as number of crossovers, with a maximum of 60.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ae8b2c48e26b4178cf6536f4ce253d9b1" title="Sets the number of crossovers used by the genetic algorithm for variable reordering.">Cudd_SetNumberXovers</a> </dd></dl>

</div>
</div>
<a id="a2651c953d81570d3f4f794bcbef40afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2651c953d81570d3f4f794bcbef40afe">&#9670;&nbsp;</a></span>Cudd_ReadOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ReadOne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the one constant of the manager. </p>
<p>The one constant is common to ADDs and BDDs.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a92900f3320df460a72eacc4ed801d69e" title="Returns the zero constant of the manager.">Cudd_ReadZero</a> <a class="el" href="cuddAPI_8c.html#a1dd42d8cb5c86659170103a3068e13a6" title="Returns the logic zero constant of the manager.">Cudd_ReadLogicZero</a> <a class="el" href="cuddAPI_8c.html#ad6d6950021b06a3bf4a6bcd05b1753e7" title="Returns the ZDD for the constant 1 function.">Cudd_ReadZddOne</a> </dd></dl>

</div>
</div>
<a id="a93f6c6fc1714330d1554a0f2e562ae1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f6c6fc1714330d1554a0f2e562ae1f">&#9670;&nbsp;</a></span>Cudd_ReadOrderRandomization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadOrderRandomization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the order randomization factor. </p>
<p>If non-zero this factor is used to determine a perturbation of the next reordering threshold. Larger factors cause larger perturbations.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a3e58f1cfc002a5a2af126f29e7377243" title="Sets the order randomization factor.">Cudd_SetOrderRandomization</a> </dd></dl>

</div>
</div>
<a id="a120dd8ff3d2b0a4df7600a820175f1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120dd8ff3d2b0a4df7600a820175f1d4">&#9670;&nbsp;</a></span>Cudd_ReadPeakLiveNodeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadPeakLiveNodeCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the peak number of live nodes. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a9ba2c88b8f70df51791c26ffde800fc7" title="Reports the number of nodes in BDDs and ADDs.">Cudd_ReadNodeCount</a> <a class="el" href="cuddAPI_8c.html#a0883e74086d9f61c2988ba614e9e649e" title="Prints out statistics and settings for a CUDD manager.">Cudd_PrintInfo</a> <a class="el" href="cuddAPI_8c.html#a39633df05be731b6b145d65f83aed572" title="Reports the peak number of nodes.">Cudd_ReadPeakNodeCount</a> </dd></dl>

</div>
</div>
<a id="a39633df05be731b6b145d65f83aed572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39633df05be731b6b145d65f83aed572">&#9670;&nbsp;</a></span>Cudd_ReadPeakNodeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Cudd_ReadPeakNodeCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the peak number of nodes. </p>
<p>This number includes node on the free list. At the peak, the number of nodes on the free list is guaranteed to be less than DD_MEM_CHUNK.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a9ba2c88b8f70df51791c26ffde800fc7" title="Reports the number of nodes in BDDs and ADDs.">Cudd_ReadNodeCount</a> <a class="el" href="cuddAPI_8c.html#a0883e74086d9f61c2988ba614e9e649e" title="Prints out statistics and settings for a CUDD manager.">Cudd_PrintInfo</a> </dd></dl>

</div>
</div>
<a id="aacfa59899b792c9f47a612ceba42c976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfa59899b792c9f47a612ceba42c976">&#9670;&nbsp;</a></span>Cudd_ReadPerm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadPerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current position of the i-th variable in the order. </p>
<p>If the index is CUDD_CONST_INDEX, returns CUDD_CONST_INDEX; otherwise, if the index is out of bounds returns -1.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ae16ce73ed2e5afcd0dd1c1db43884d2a" title="Returns the index of the variable currently in the i-th position of the order.">Cudd_ReadInvPerm</a> <a class="el" href="cuddAPI_8c.html#a965c64ce6822b03441ce7445e8187aa3" title="Returns the current position of the i-th ZDD variable in the order.">Cudd_ReadPermZdd</a> </dd></dl>

</div>
</div>
<a id="a965c64ce6822b03441ce7445e8187aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a965c64ce6822b03441ce7445e8187aa3">&#9670;&nbsp;</a></span>Cudd_ReadPermZdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadPermZdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current position of the i-th ZDD variable in the order. </p>
<p>If the index is CUDD_CONST_INDEX, returns CUDD_CONST_INDEX; otherwise, if the index is out of bounds returns -1.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a30f47219044e26a1be7699014dcc021a" title="Returns the index of the ZDD variable currently in the i-th position of the order.">Cudd_ReadInvPermZdd</a> <a class="el" href="cuddAPI_8c.html#aacfa59899b792c9f47a612ceba42c976" title="Returns the current position of the i-th variable in the order.">Cudd_ReadPerm</a> </dd></dl>

</div>
</div>
<a id="af581badbfb76ba5909f83482c47d743e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af581badbfb76ba5909f83482c47d743e">&#9670;&nbsp;</a></span>Cudd_ReadPlusInfinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ReadPlusInfinity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the plus-infinity constant from the manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a1e760e63a14cd28172b2371c8419b0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e760e63a14cd28172b2371c8419b0d9">&#9670;&nbsp;</a></span>Cudd_ReadPopulationSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadPopulationSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the current size of the population used by the genetic algorithm for variable reordering. </p>
<p>A larger population size will cause the genetic algorithm to take more time, but will generally produce better results. The default value is 0, in which case the package uses three times the number of variables as population size, with a maximum of 120.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#abbdf2ca87a414bb36bfbb6247a8915ec" title="Sets the size of the population used by the genetic algorithm for variable reordering.">Cudd_SetPopulationSize</a> </dd></dl>

</div>
</div>
<a id="ac305e7d5aaa2c3808db94795dc0a1150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac305e7d5aaa2c3808db94795dc0a1150">&#9670;&nbsp;</a></span>Cudd_ReadRecomb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadRecomb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current value of the recombination parameter used in group sifting. </p>
<p>A larger (positive) value makes the aggregation of variables due to the second difference criterion more likely. A smaller (negative) value makes aggregation less likely.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac68f934b27bc1d1ea947f410c8aedd36" title="Sets the value of the recombination parameter used in group sifting.">Cudd_SetRecomb</a> </dd></dl>

</div>
</div>
<a id="a3d8ec5d88cf36fd80006b157252be029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8ec5d88cf36fd80006b157252be029">&#9670;&nbsp;</a></span>Cudd_ReadRecursiveCalls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadRecursiveCalls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of recursive calls. </p>
<p>Returns the number of recursive calls if the package is compiled with DD_COUNT defined.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="aa5283d665223378e10425342dad1684b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5283d665223378e10425342dad1684b">&#9670;&nbsp;</a></span>Cudd_ReadReorderingCycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadReorderingCycle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the reordCycle parameter of the manager. </p>
<p>This parameter determines how often the alternate threshold on maximum growth is used in reordering.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a692abb5fde2011b2a3cec010946eebca" title="Reads the maxGrowthAlt parameter of the manager.">Cudd_ReadMaxGrowthAlternate</a> <a class="el" href="cuddAPI_8c.html#a7d4358c1f00a31b657c937b8e64ec6e6" title="Sets the maxGrowthAlt parameter of the manager.">Cudd_SetMaxGrowthAlternate</a> <a class="el" href="cuddAPI_8c.html#afd23a86c046d74935d746757846d1148" title="Sets the reordCycle parameter of the manager.">Cudd_SetReorderingCycle</a> </dd></dl>

</div>
</div>
<a id="ac22056db7260493748eda0162431cd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22056db7260493748eda0162431cd76">&#9670;&nbsp;</a></span>Cudd_ReadReorderings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadReorderings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of times reordering has occurred. </p>
<p>The number includes both the calls to Cudd_ReduceHeap from the application program and those automatically performed by the package. However, calls that do not even initiate reordering are not counted. A call may not initiate reordering if there are fewer than minsize live nodes in the manager, or if CUDD_REORDER_NONE is specified as reordering method. The calls to Cudd_ShuffleHeap are not counted.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddReorder_8c.html#a02a5a86dfb8ebc7726d6cf56b6a7eec1" title="Main dynamic reordering routine.">Cudd_ReduceHeap</a> <a class="el" href="cuddAPI_8c.html#a61141274ba36755e4c88a4c1597b9847" title="Returns the time spent in reordering.">Cudd_ReadReorderingTime</a> </dd></dl>

</div>
</div>
<a id="a61141274ba36755e4c88a4c1597b9847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61141274ba36755e4c88a4c1597b9847">&#9670;&nbsp;</a></span>Cudd_ReadReorderingTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Cudd_ReadReorderingTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the time spent in reordering. </p>
<p>Returns the number of milliseconds spent reordering variables since the manager was initialized. The time spent in collecting garbage before reordering is included.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac22056db7260493748eda0162431cd76" title="Returns the number of times reordering has occurred.">Cudd_ReadReorderings</a> </dd></dl>

</div>
</div>
<a id="a54fbfd8fa0597af542ad9dfa4eefa2da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fbfd8fa0597af542ad9dfa4eefa2da">&#9670;&nbsp;</a></span>Cudd_ReadSiftMaxSwap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadSiftMaxSwap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the siftMaxSwap parameter of the manager. </p>
<p>This parameter gives the maximum number of swaps that will be attempted for each invocation of sifting. The real number of swaps may exceed the set limit because the package will always complete the sifting of the variable that causes the limit to be reached.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a112841ed78d8f90d31ee879684775b51" title="Reads the siftMaxVar parameter of the manager.">Cudd_ReadSiftMaxVar</a> <a class="el" href="cuddAPI_8c.html#a40246082da9de77243088f935be6e2e6" title="Sets the siftMaxSwap parameter of the manager.">Cudd_SetSiftMaxSwap</a> </dd></dl>

</div>
</div>
<a id="a112841ed78d8f90d31ee879684775b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112841ed78d8f90d31ee879684775b51">&#9670;&nbsp;</a></span>Cudd_ReadSiftMaxVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadSiftMaxVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the siftMaxVar parameter of the manager. </p>
<p>This parameter gives the maximum number of variables that will be sifted for each invocation of sifting.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a54fbfd8fa0597af542ad9dfa4eefa2da" title="Reads the siftMaxSwap parameter of the manager.">Cudd_ReadSiftMaxSwap</a> <a class="el" href="cuddAPI_8c.html#a23ad3e7bf12607f58756e15f2b1251aa" title="Sets the siftMaxVar parameter of the manager.">Cudd_SetSiftMaxVar</a> </dd></dl>

</div>
</div>
<a id="ab1647f3f86f4e555bea35673f9539f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1647f3f86f4e555bea35673f9539f94">&#9670;&nbsp;</a></span>Cudd_ReadSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of BDD variables in existance. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a82a5d45fa3fb62aa72a3aa280c563f9d" title="Returns the number of ZDD variables in existance.">Cudd_ReadZddSize</a> </dd></dl>

</div>
</div>
<a id="a3787560300153655851b4fe3c7646b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3787560300153655851b4fe3c7646b0c">&#9670;&nbsp;</a></span>Cudd_ReadSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadSlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of slots of the unique table. </p>
<p>This number is mainly for diagnostic purposes.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="ae94781bf6e62d0c6a3439b4db11b50e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94781bf6e62d0c6a3439b4db11b50e5">&#9670;&nbsp;</a></span>Cudd_ReadStartTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Cudd_ReadStartTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the start time of the manager. </p>
<p>This is initially set to the number of milliseconds since the program started, but may be reset by the application.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2b42ab1fa12990140dbfd415bc7a6231" title="Sets the start time of the manager.">Cudd_SetStartTime</a> <a class="el" href="cuddAPI_8c.html#ac8bbaa787eb4bbf866292ea6f566e427" title="Resets the start time of the manager.">Cudd_ResetStartTime</a> <a class="el" href="cuddAPI_8c.html#a855a253235b54ff16fd66c6e43241069" title="Returns the time limit for the manager.">Cudd_ReadTimeLimit</a> </dd></dl>

</div>
</div>
<a id="a9830fe86096e7721263e058ba7d93d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9830fe86096e7721263e058ba7d93d26">&#9670;&nbsp;</a></span>Cudd_ReadStderr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* Cudd_ReadStderr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the stderr of a manager. </p>
<p>This is the file pointer to which messages normally going to stderr are written. It is initialized to stderr. Cudd_SetStderr allows the application to redirect it.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a910e7309dc7551140d71871619ead247" title="Sets the stderr of a manager.">Cudd_SetStderr</a> <a class="el" href="cuddAPI_8c.html#a811b2599d1ed4a66001b7577cbbbd33d" title="Reads the stdout of a manager.">Cudd_ReadStdout</a> </dd></dl>

</div>
</div>
<a id="a811b2599d1ed4a66001b7577cbbbd33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811b2599d1ed4a66001b7577cbbbd33d">&#9670;&nbsp;</a></span>Cudd_ReadStdout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* Cudd_ReadStdout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the stdout of a manager. </p>
<p>This is the file pointer to which messages normally going to stdout are written. It is initialized to stdout. Cudd_SetStdout allows the application to redirect it.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac3080103403d6ba1f79b04f4e701edbc" title="Sets the stdout of a manager.">Cudd_SetStdout</a> <a class="el" href="cuddAPI_8c.html#a9830fe86096e7721263e058ba7d93d26" title="Reads the stderr of a manager.">Cudd_ReadStderr</a> </dd></dl>

</div>
</div>
<a id="a2cb92ccf940cabf261d35ccc1945e7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb92ccf940cabf261d35ccc1945e7cf">&#9670;&nbsp;</a></span>Cudd_ReadSwapSteps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadSwapSteps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the number of elementary reordering steps. </p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>

</div>
</div>
<a id="a3028ccbe6fb46efd6565d0f4aab78738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3028ccbe6fb46efd6565d0f4aab78738">&#9670;&nbsp;</a></span>Cudd_ReadSymmviolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadSymmviolation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current value of the symmviolation parameter used in group sifting. </p>
<p>This parameter is used in group sifting to decide how many violations to the symmetry conditions <code>f10 = f01</code> or <code>f11 = f00</code> are tolerable when checking for aggregation due to extended symmetry. The value should be between 0 and 100. A small value causes fewer variables to be aggregated. The default value is 0.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a5bb84b628160417172cb44e22e2067b7" title="Sets the value of the symmviolation parameter used in group sifting.">Cudd_SetSymmviolation</a> </dd></dl>

</div>
</div>
<a id="a855a253235b54ff16fd66c6e43241069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855a253235b54ff16fd66c6e43241069">&#9670;&nbsp;</a></span>Cudd_ReadTimeLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Cudd_ReadTimeLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the time limit for the manager. </p>
<p>This is initially set to a very large number, but may be reset by the application. The time is expressed in milliseconds.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac6e694e133632d34256646869f076ff5" title="Sets the time limit for the manager.">Cudd_SetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aeeb6240810097270fd1414536de17eb0" title="Updates the time limit for the manager.">Cudd_UpdateTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aa497c8cb498833021f18813fb5813b57" title="Unsets the time limit for the manager.">Cudd_UnsetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a333169d352f3ab54002eaae738a39d68" title="Increases the time limit for the manager.">Cudd_IncreaseTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a7c3b2370790803f37aace1dfc0a7d1cc" title="Returns true if the time limit for the manager is set.">Cudd_TimeLimited</a> <a class="el" href="cuddAPI_8c.html#ae94781bf6e62d0c6a3439b4db11b50e5" title="Returns the start time of the manager.">Cudd_ReadStartTime</a> </dd></dl>

</div>
</div>
<a id="a4b1312ca893e36e0b628804b12e5df32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1312ca893e36e0b628804b12e5df32">&#9670;&nbsp;</a></span>Cudd_ReadTimeoutHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#a55dd2f7df5ab2f9df7e9e5c969adc0aa">DD_TOHFP</a> Cudd_ReadTimeoutHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>argp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the current timeout handler function. </p>
<dl class="section user"><dt>Side effects\n If argp is non-null, the second argument to</dt><dd>the handler is written to the location it points to.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a122a5e97bfebdc0362991d1caaa96115" title="Register a timeout handler function.">Cudd_RegisterTimeoutHandler</a> </dd></dl>

</div>
</div>
<a id="a6ee8468f5b7fe67a0f609412e211632b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee8468f5b7fe67a0f609412e211632b">&#9670;&nbsp;</a></span>Cudd_ReadTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mtr_8h.html#ac77933bac85945a324b3ddacebbe899b">MtrNode</a>* Cudd_ReadTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the variable group tree of the manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2aa3827dfffcc29254520628b15aab55" title="Sets the variable group tree of the manager.">Cudd_SetTree</a> <a class="el" href="cuddAPI_8c.html#af5c6ecb39244a6db49494d1f1e31bd1a" title="Frees the variable group tree of the manager.">Cudd_FreeTree</a> <a class="el" href="cuddAPI_8c.html#ad3d3dbe0fa509a7f70691dcb6d8726ad" title="Returns the variable group tree of the manager.">Cudd_ReadZddTree</a> </dd></dl>

</div>
</div>
<a id="aaaa1d598d1d5830c72b33aca86e511c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa1d598d1d5830c72b33aca86e511c1">&#9670;&nbsp;</a></span>Cudd_ReadUniqueLinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadUniqueLinks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of links followed in the unique table. </p>
<p>Returns the number of links followed during look-ups in the unique table if the keeping of this statistic is enabled; -1 otherwise. If an item is found in the first position of its collision list, the number of links followed is taken to be 0. If it is in second position, the number of links is 1, and so on. This statistic is enabled only if the package is compiled with DD_UNIQUE_PROFILE defined.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#acebf224e24889082c229d56db1f982f3" title="Returns the number of look-ups in the unique table.">Cudd_ReadUniqueLookUps</a> </dd></dl>

</div>
</div>
<a id="acebf224e24889082c229d56db1f982f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acebf224e24889082c229d56db1f982f3">&#9670;&nbsp;</a></span>Cudd_ReadUniqueLookUps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadUniqueLookUps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of look-ups in the unique table. </p>
<p>Returns the number of look-ups in the unique table if the keeping of this statistic is enabled; -1 otherwise. This statistic is enabled only if the package is compiled with DD_UNIQUE_PROFILE defined.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aaaa1d598d1d5830c72b33aca86e511c1" title="Returns the number of links followed in the unique table.">Cudd_ReadUniqueLinks</a> </dd></dl>

</div>
</div>
<a id="a0941cb7338ba1a71f3451f4c2a747093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0941cb7338ba1a71f3451f4c2a747093">&#9670;&nbsp;</a></span>Cudd_ReadUsedSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadUsedSlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the fraction of used slots in the unique table. </p>
<p>The unused slots are those in which no valid data is stored. Garbage collection, variable reordering, and subtable resizing may cause used slots to become unused.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a3787560300153655851b4fe3c7646b0c" title="Returns the total number of slots of the unique table.">Cudd_ReadSlots</a> </dd></dl>

</div>
</div>
<a id="a44d8f64c98953fd110d0e5146bcadaca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d8f64c98953fd110d0e5146bcadaca">&#9670;&nbsp;</a></span>Cudd_ReadVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ReadVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the i-th element of the vars array. </p>
<p>Returns the i-th element of the vars array if it falls within the array bounds; NULL otherwise. If i is the index of an existing variable, this function produces the same result as Cudd_bddIthVar. However, if the i-th var does not exist yet, Cudd_bddIthVar will create it, whereas Cudd_ReadVars will not.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a40fd71665cde402bd5bc4f39015c09ae" title="Returns the BDD variable with index i.">Cudd_bddIthVar</a> </dd></dl>

</div>
</div>
<a id="ad6d6950021b06a3bf4a6bcd05b1753e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d6950021b06a3bf4a6bcd05b1753e7">&#9670;&nbsp;</a></span>Cudd_ReadZddOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ReadZddOne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ZDD for the constant 1 function. </p>
<p>The representation of the constant 1 function as a ZDD depends on how many variables it (nominally) depends on. The index of the topmost variable in the support is given as argument <code>i</code>.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2651c953d81570d3f4f794bcbef40afe" title="Returns the one constant of the manager.">Cudd_ReadOne</a> </dd></dl>

</div>
</div>
<a id="a82a5d45fa3fb62aa72a3aa280c563f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a5d45fa3fb62aa72a3aa280c563f9d">&#9670;&nbsp;</a></span>Cudd_ReadZddSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadZddSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of ZDD variables in existance. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>

</div>
</div>
<a id="ad3d3dbe0fa509a7f70691dcb6d8726ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d3dbe0fa509a7f70691dcb6d8726ad">&#9670;&nbsp;</a></span>Cudd_ReadZddTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mtr_8h.html#ac77933bac85945a324b3ddacebbe899b">MtrNode</a>* Cudd_ReadZddTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the variable group tree of the manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2cdbbc9e78a4f0684a118f304eb1a455" title="Sets the ZDD variable group tree of the manager.">Cudd_SetZddTree</a> <a class="el" href="cuddAPI_8c.html#ac9a25622e38ad302c050803d520f5fce" title="Frees the variable group tree of the manager.">Cudd_FreeZddTree</a> <a class="el" href="cuddAPI_8c.html#a6ee8468f5b7fe67a0f609412e211632b" title="Returns the variable group tree of the manager.">Cudd_ReadTree</a> </dd></dl>

</div>
</div>
<a id="a92900f3320df460a72eacc4ed801d69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92900f3320df460a72eacc4ed801d69e">&#9670;&nbsp;</a></span>Cudd_ReadZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ReadZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the zero constant of the manager. </p>
<p>The zero constant is the arithmetic zero, rather than the logic zero. The latter is the complement of the one constant.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2651c953d81570d3f4f794bcbef40afe" title="Returns the one constant of the manager.">Cudd_ReadOne</a> <a class="el" href="cuddAPI_8c.html#a1dd42d8cb5c86659170103a3068e13a6" title="Returns the logic zero constant of the manager.">Cudd_ReadLogicZero</a> </dd></dl>

</div>
</div>
<a id="a6aa76d8075f1af649c8741af26369836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa76d8075f1af649c8741af26369836">&#9670;&nbsp;</a></span>Cudd_RegisterOutOfMemoryCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#ab7b4676c7e2dd36567b3749740ca8b60">DD_OOMFP</a> Cudd_RegisterOutOfMemoryCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#ab7b4676c7e2dd36567b3749740ca8b60">DD_OOMFP</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs an out-of-memory callback. </p>
<p>Registers a callback function that is called when a discretionary memory allocation fails.</p>
<dl class="section return"><dt>Returns</dt><dd>the old callback function.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a1b6966d8f04f26fd49495f3703a771ce" title="Unregister an out-of-memory callback.">Cudd_UnregisterOutOfMemoryCallback</a> <a class="el" href="cuddUtil_8c.html#a77cf07a23729b7f2621c74bf1e2ff830" title="Warns that a memory allocation failed.">Cudd_OutOfMem</a> <a class="el" href="cuddUtil_8c.html#aa6e655bc7b71ea719534f40fb8faa393" title="Doesn not warn that a memory allocation failed.">Cudd_OutOfMemSilent</a> </dd></dl>

</div>
</div>
<a id="a5dbdd1ef4d92a8f7d60304e2cc17ff6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbdd1ef4d92a8f7d60304e2cc17ff6e">&#9670;&nbsp;</a></span>Cudd_RegisterTerminationCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_RegisterTerminationCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#ab19edd4d89e40f721e04dbdeb3e36684">DD_THFP</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs a termination callback. </p>
<p>Registers a callback function that is called from time to time to decide whether computation should be abandoned.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a8014219cc6794497d58c3eeb140db8c8" title="Unregisters a termination callback.">Cudd_UnregisterTerminationCallback</a> </dd></dl>

</div>
</div>
<a id="a122a5e97bfebdc0362991d1caaa96115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122a5e97bfebdc0362991d1caaa96115">&#9670;&nbsp;</a></span>Cudd_RegisterTimeoutHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_RegisterTimeoutHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a55dd2f7df5ab2f9df7e9e5c969adc0aa">DD_TOHFP</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a timeout handler function. </p>
<p>To unregister a handler, register a NULL pointer.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a4b1312ca893e36e0b628804b12e5df32" title="Read the current timeout handler function.">Cudd_ReadTimeoutHandler</a> </dd></dl>

</div>
</div>
<a id="a0c732be4af510054662cd6e6f0a5772f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c732be4af510054662cd6e6f0a5772f">&#9670;&nbsp;</a></span>Cudd_RemoveHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_RemoveHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a1a0b162633be038685ce87dac7a57382">DD_HFP</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#afbec19daded82939f6045c92b3a7bde2">Cudd_HookType</a>&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a function from a hook. </p>
<p>A hook is a list of application-provided functions called on certain occasions by the package.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 the function was not in the list.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a6884f064de544463f006f9104e4afa74" title="Adds a function to a hook.">Cudd_AddHook</a> </dd></dl>

</div>
</div>
<a id="a4a634a339969d6d84e3db858f3f77be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a634a339969d6d84e3db858f3f77be4">&#9670;&nbsp;</a></span>Cudd_ReorderingReporting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReorderingReporting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 1 if reporting of reordering stats is enabled; 0 otherwise. </p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#adfe5374e85cf3fb0827307b1e3cc5e07" title="Enables reporting of reordering stats.">Cudd_EnableReorderingReporting</a> <a class="el" href="cuddAPI_8c.html#a249298e38710246ab1ead014cfe54dd9" title="Disables reporting of reordering stats.">Cudd_DisableReorderingReporting</a> </dd></dl>

</div>
</div>
<a id="a3806c2327487b3cea3c7ffff75aead83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3806c2327487b3cea3c7ffff75aead83">&#9670;&nbsp;</a></span>Cudd_ReorderingStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReorderingStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a> *&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the status of automatic dynamic reordering of BDDs and ADDs. </p>
<p>The location pointed by parameter method is set to the reordering method currently selected if method is non-null.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if automatic reordering is enabled; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The location pointed by parameter method is set to the</dt><dd>reordering method currently selected if method is non-null.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a6a0d69b4288f36d5d377c460d49066a6" title="Enables automatic dynamic reordering of BDDs and ADDs.">Cudd_AutodynEnable</a> <a class="el" href="cuddAPI_8c.html#affd2c1c2a110944c1d760de577aed431" title="Disables automatic dynamic reordering.">Cudd_AutodynDisable</a> <a class="el" href="cuddAPI_8c.html#ac6f65c44244489bfbb37137929baf0cd" title="Reports the status of automatic dynamic reordering of ZDDs.">Cudd_ReorderingStatusZdd</a> </dd></dl>

</div>
</div>
<a id="ac6f65c44244489bfbb37137929baf0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f65c44244489bfbb37137929baf0cd">&#9670;&nbsp;</a></span>Cudd_ReorderingStatusZdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReorderingStatusZdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a> *&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the status of automatic dynamic reordering of ZDDs. </p>
<p>Parameter method is set to the ZDD reordering method currently selected.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if automatic reordering is enabled; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n Parameter method is set to the ZDD reordering method currently</dt><dd>selected.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a709e0e15a38d6d6e9c83ff8b8a9d07f2" title="Enables automatic dynamic reordering of ZDDs.">Cudd_AutodynEnableZdd</a> <a class="el" href="cuddAPI_8c.html#a219ccb201e3c1aa25ebef007399849fa" title="Disables automatic dynamic reordering of ZDDs.">Cudd_AutodynDisableZdd</a> <a class="el" href="cuddAPI_8c.html#a3806c2327487b3cea3c7ffff75aead83" title="Reports the status of automatic dynamic reordering of BDDs and ADDs.">Cudd_ReorderingStatus</a> </dd></dl>

</div>
</div>
<a id="ac8bbaa787eb4bbf866292ea6f566e427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bbaa787eb4bbf866292ea6f566e427">&#9670;&nbsp;</a></span>Cudd_ResetStartTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_ResetStartTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the start time of the manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ae94781bf6e62d0c6a3439b4db11b50e5" title="Returns the start time of the manager.">Cudd_ReadStartTime</a> <a class="el" href="cuddAPI_8c.html#a2b42ab1fa12990140dbfd415bc7a6231" title="Sets the start time of the manager.">Cudd_SetStartTime</a> <a class="el" href="cuddAPI_8c.html#ac6e694e133632d34256646869f076ff5" title="Sets the time limit for the manager.">Cudd_SetTimeLimit</a> </dd></dl>

</div>
</div>
<a id="a2d4a097e769d11868f760b920e6f1da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4a097e769d11868f760b920e6f1da8">&#9670;&nbsp;</a></span>Cudd_SetApplicationHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetApplicationHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the application hook. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a9f98975109e7d3afd1bad0716e4d6666" title="Reads the application hook.">Cudd_ReadApplicationHook</a> </dd></dl>

</div>
</div>
<a id="a3064405f352a9d93a6ee16cfa5d2512c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3064405f352a9d93a6ee16cfa5d2512c">&#9670;&nbsp;</a></span>Cudd_SetArcviolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetArcviolation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arcviolation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the arcviolation parameter used in group sifting. </p>
<p>This parameter is used to decide how many arcs into <code>y</code> not coming from <code>x</code> are tolerable when checking for aggregation due to extended symmetry. The value should be between 0 and 100. A small value causes fewer variables to be aggregated. The default value is 0.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a89117a52be055c338311b1380d511375" title="Returns the current value of the arcviolation parameter used in group sifting.">Cudd_ReadArcviolation</a> </dd></dl>

</div>
</div>
<a id="a3792749a2a10045b60d2a3d99d99928e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3792749a2a10045b60d2a3d99d99928e">&#9670;&nbsp;</a></span>Cudd_SetBackground()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetBackground </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>bck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the background constant of the manager. </p>
<p>It assumes that the <a class="el" href="structDdNode.html" title="Decision diagram node.">DdNode</a> pointer bck is already referenced.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a30ef132c1f56bdb0e26efc81fa695cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ef132c1f56bdb0e26efc81fa695cf3">&#9670;&nbsp;</a></span>Cudd_SetEpsilon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetEpsilon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a>&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the epsilon parameter of the manager to ep. </p>
<p>The epsilon parameter control the comparison between floating point numbers.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac711d8ce9d243e16246b83e3c1f04199" title="Reads the epsilon parameter of the manager.">Cudd_ReadEpsilon</a> </dd></dl>

</div>
</div>
<a id="aee7e7fa94656ed131aa67ca1ea15a031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7e7fa94656ed131aa67ca1ea15a031">&#9670;&nbsp;</a></span>Cudd_SetGroupcheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetGroupcheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a8b2572b778b7e8bd68afcd4aa1f0ce33">Cudd_AggregationType</a>&#160;</td>
          <td class="paramname"><em>gc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the parameter groupcheck of the manager to gc. </p>
<p>The groupcheck parameter determines the aggregation criterion in group sifting.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>Cudd_ReadGroupCheck </dd></dl>

</div>
</div>
<a id="a1952bb97db9782bcf607d169c842b7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1952bb97db9782bcf607d169c842b7ce">&#9670;&nbsp;</a></span>Cudd_SetLooseUpTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetLooseUpTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>lut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the looseUpTo parameter of the manager. </p>
<p>This parameter of the manager controls the threshold beyond which no fast growth of the unique table is allowed. The threshold is given as a number of slots. If the value passed to this function is 0, the function determines a suitable value based on the available memory.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ab452b9f1bbcdb8bf49cbea25f6e8ed8d" title="Reads the looseUpTo parameter of the manager.">Cudd_ReadLooseUpTo</a> <a class="el" href="cuddAPI_8c.html#ae96f3e2036a77ab8c1318e607dea232b" title="Sets the hit rate that causes resizinig of the computed table.">Cudd_SetMinHit</a> </dd></dl>

</div>
</div>
<a id="a4ced83212c4c45f94d8957e3fab485c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ced83212c4c45f94d8957e3fab485c5">&#9670;&nbsp;</a></span>Cudd_SetMaxCacheHard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetMaxCacheHard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>mc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maxCacheHard parameter of the manager. </p>
<p>The cache cannot grow larger than maxCacheHard entries. This parameter allows an application to control the trade-off of memory versus speed. If the value passed to this function is 0, the function determines a suitable maximum cache size based on the available memory.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#acfac0e32bb4bcfe7f0035f4fff401a0e" title="Reads the maxCacheHard parameter of the manager.">Cudd_ReadMaxCacheHard</a> Cudd_SetMaxCache </dd></dl>

</div>
</div>
<a id="aa3a621a6133ce4203b8bfa351d5de4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a621a6133ce4203b8bfa351d5de4ea">&#9670;&nbsp;</a></span>Cudd_SetMaxGrowth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetMaxGrowth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maxGrowth parameter of the manager. </p>
<p>This parameter determines how much the number of nodes can grow during sifting of a variable. Overall, sifting never increases the size of the decision diagrams. This parameter only refers to intermediate results. A lower value will speed up sifting, possibly at the expense of quality.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a23f3600540de47d20e85eb4036af6e49" title="Reads the maxGrowth parameter of the manager.">Cudd_ReadMaxGrowth</a> <a class="el" href="cuddAPI_8c.html#a7d4358c1f00a31b657c937b8e64ec6e6" title="Sets the maxGrowthAlt parameter of the manager.">Cudd_SetMaxGrowthAlternate</a> </dd></dl>

</div>
</div>
<a id="a7d4358c1f00a31b657c937b8e64ec6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4358c1f00a31b657c937b8e64ec6e6">&#9670;&nbsp;</a></span>Cudd_SetMaxGrowthAlternate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetMaxGrowthAlternate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maxGrowthAlt parameter of the manager. </p>
<p>This parameter is analogous to the maxGrowth paramter, and is used every given number of reorderings instead of maxGrowth. The number of reorderings is set with Cudd_SetReorderingCycle. If the number of reorderings is 0 (default) maxGrowthAlt is never used.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a692abb5fde2011b2a3cec010946eebca" title="Reads the maxGrowthAlt parameter of the manager.">Cudd_ReadMaxGrowthAlternate</a> <a class="el" href="cuddAPI_8c.html#aa3a621a6133ce4203b8bfa351d5de4ea" title="Sets the maxGrowth parameter of the manager.">Cudd_SetMaxGrowth</a> <a class="el" href="cuddAPI_8c.html#afd23a86c046d74935d746757846d1148" title="Sets the reordCycle parameter of the manager.">Cudd_SetReorderingCycle</a> <a class="el" href="cuddAPI_8c.html#aa5283d665223378e10425342dad1684b" title="Reads the reordCycle parameter of the manager.">Cudd_ReadReorderingCycle</a> </dd></dl>

</div>
</div>
<a id="ac553f7975b60ebe4a38141cbff1eebea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac553f7975b60ebe4a38141cbff1eebea">&#9670;&nbsp;</a></span>Cudd_SetMaxLive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetMaxLive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxLive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum allowed number of live nodes. </p>
<p>When this number is exceeded, the package returns NULL.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#af6afbdb9c3955275888ec9cb60711a57" title="Reads the maximum allowed number of live nodes.">Cudd_ReadMaxLive</a> </dd></dl>

</div>
</div>
<a id="a0d15a525874908e9230881bccabbb993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d15a525874908e9230881bccabbb993">&#9670;&nbsp;</a></span>Cudd_SetMaxMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Cudd_SetMaxMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxMemory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum allowed memory. </p>
<p>When this number is exceeded, the package returns NULL.</p>
<dl class="section return"><dt>Returns</dt><dd>the previous limit.</dd></dl>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aef52798a6b7994a3038335d36ec9f051" title="Reads the maximum allowed memory.">Cudd_ReadMaxMemory</a> </dd></dl>

</div>
</div>
<a id="a3a2e39aeebc215847d374a01bb1f182b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2e39aeebc215847d374a01bb1f182b">&#9670;&nbsp;</a></span>Cudd_SetMaxReorderings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetMaxReorderings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>mr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum number of times reordering may be invoked. </p>
<p>The default value is (practically) infinite.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac22056db7260493748eda0162431cd76" title="Returns the number of times reordering has occurred.">Cudd_ReadReorderings</a> <a class="el" href="cuddAPI_8c.html#ad011aad1e779f0e31ab67cf7a1d7f591" title="Returns the maximum number of times reordering may be invoked.">Cudd_ReadMaxReorderings</a> <a class="el" href="cuddReorder_8c.html#a02a5a86dfb8ebc7726d6cf56b6a7eec1" title="Main dynamic reordering routine.">Cudd_ReduceHeap</a> </dd></dl>

</div>
</div>
<a id="ae96f3e2036a77ab8c1318e607dea232b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96f3e2036a77ab8c1318e607dea232b">&#9670;&nbsp;</a></span>Cudd_SetMinHit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetMinHit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>hr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the hit rate that causes resizinig of the computed table. </p>
<p>Sets the minHit parameter of the manager. This parameter controls the resizing of the computed table. If the hit rate is larger than the specified value, and the cache is not already too large, then its size is doubled.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a79695ef1e6f821d310f5613a6d8ba148" title="Reads the hit rate that causes resizinig of the computed table.">Cudd_ReadMinHit</a> </dd></dl>

</div>
</div>
<a id="a3d62c965eabd4ec777af47acd790ee47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d62c965eabd4ec777af47acd790ee47">&#9670;&nbsp;</a></span>Cudd_SetNextReordering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetNextReordering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the threshold for the next dynamic reordering. </p>
<p>The threshold is in terms of number of nodes and is in effect only if reordering is enabled. The count does not include the dead nodes, unless the countDead parameter of the manager has been changed from its default setting.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#adc3820fb326bce09797fda8439b5daa4" title="Returns the threshold for the next dynamic reordering.">Cudd_ReadNextReordering</a> </dd></dl>

</div>
</div>
<a id="ae8b2c48e26b4178cf6536f4ce253d9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b2c48e26b4178cf6536f4ce253d9b1">&#9670;&nbsp;</a></span>Cudd_SetNumberXovers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetNumberXovers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberXovers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of crossovers used by the genetic algorithm for variable reordering. </p>
<p>A larger number of crossovers will cause the genetic algorithm to take more time, but will generally produce better results. The default value is 0, in which case the package uses three times the number of variables as number of crossovers, with a maximum of 60.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2609fe9051be1a8ab6d305d38bfb5956" title="Reads the current number of crossovers used by the genetic algorithm for variable reordering.">Cudd_ReadNumberXovers</a> </dd></dl>

</div>
</div>
<a id="a3e58f1cfc002a5a2af126f29e7377243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e58f1cfc002a5a2af126f29e7377243">&#9670;&nbsp;</a></span>Cudd_SetOrderRandomization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetOrderRandomization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the order randomization factor. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a93f6c6fc1714330d1554a0f2e562ae1f" title="Returns the order randomization factor.">Cudd_ReadOrderRandomization</a> </dd></dl>

</div>
</div>
<a id="abbdf2ca87a414bb36bfbb6247a8915ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdf2ca87a414bb36bfbb6247a8915ec">&#9670;&nbsp;</a></span>Cudd_SetPopulationSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetPopulationSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>populationSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the size of the population used by the genetic algorithm for variable reordering. </p>
<p>A larger population size will cause the genetic algorithm to take more time, but will generally produce better results. The default value is 0, in which case the package uses three times the number of variables as population size, with a maximum of 120.</p>
<dl class="section user"><dt>Side effects\n Changes the manager.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a1e760e63a14cd28172b2371c8419b0d9" title="Reads the current size of the population used by the genetic algorithm for variable reordering.">Cudd_ReadPopulationSize</a> </dd></dl>

</div>
</div>
<a id="ac68f934b27bc1d1ea947f410c8aedd36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68f934b27bc1d1ea947f410c8aedd36">&#9670;&nbsp;</a></span>Cudd_SetRecomb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetRecomb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recomb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the recombination parameter used in group sifting. </p>
<p>A larger (positive) value makes the aggregation of variables due to the second difference criterion more likely. A smaller (negative) value makes aggregation less likely. The default value is 0.</p>
<dl class="section user"><dt>Side effects\n Changes the manager.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac305e7d5aaa2c3808db94795dc0a1150" title="Returns the current value of the recombination parameter used in group sifting.">Cudd_ReadRecomb</a> </dd></dl>

</div>
</div>
<a id="afd23a86c046d74935d746757846d1148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd23a86c046d74935d746757846d1148">&#9670;&nbsp;</a></span>Cudd_SetReorderingCycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetReorderingCycle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the reordCycle parameter of the manager. </p>
<p>This parameter determines how often the alternate threshold on maximum growth is used in reordering.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a692abb5fde2011b2a3cec010946eebca" title="Reads the maxGrowthAlt parameter of the manager.">Cudd_ReadMaxGrowthAlternate</a> <a class="el" href="cuddAPI_8c.html#a7d4358c1f00a31b657c937b8e64ec6e6" title="Sets the maxGrowthAlt parameter of the manager.">Cudd_SetMaxGrowthAlternate</a> <a class="el" href="cuddAPI_8c.html#aa5283d665223378e10425342dad1684b" title="Reads the reordCycle parameter of the manager.">Cudd_ReadReorderingCycle</a> </dd></dl>

</div>
</div>
<a id="a40246082da9de77243088f935be6e2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40246082da9de77243088f935be6e2e6">&#9670;&nbsp;</a></span>Cudd_SetSiftMaxSwap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetSiftMaxSwap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the siftMaxSwap parameter of the manager. </p>
<p>This parameter gives the maximum number of swaps that will be attempted for each invocation of sifting. The real number of swaps may exceed the set limit because the package will always complete the sifting of the variable that causes the limit to be reached.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a23ad3e7bf12607f58756e15f2b1251aa" title="Sets the siftMaxVar parameter of the manager.">Cudd_SetSiftMaxVar</a> <a class="el" href="cuddAPI_8c.html#a54fbfd8fa0597af542ad9dfa4eefa2da" title="Reads the siftMaxSwap parameter of the manager.">Cudd_ReadSiftMaxSwap</a> </dd></dl>

</div>
</div>
<a id="a23ad3e7bf12607f58756e15f2b1251aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ad3e7bf12607f58756e15f2b1251aa">&#9670;&nbsp;</a></span>Cudd_SetSiftMaxVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetSiftMaxVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>smv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the siftMaxVar parameter of the manager. </p>
<p>This parameter gives the maximum number of variables that will be sifted for each invocation of sifting.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a40246082da9de77243088f935be6e2e6" title="Sets the siftMaxSwap parameter of the manager.">Cudd_SetSiftMaxSwap</a> <a class="el" href="cuddAPI_8c.html#a112841ed78d8f90d31ee879684775b51" title="Reads the siftMaxVar parameter of the manager.">Cudd_ReadSiftMaxVar</a> </dd></dl>

</div>
</div>
<a id="a2b42ab1fa12990140dbfd415bc7a6231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b42ab1fa12990140dbfd415bc7a6231">&#9670;&nbsp;</a></span>Cudd_SetStartTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetStartTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>st</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the start time of the manager. </p>
<p>The time must be expressed in milliseconds.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ae94781bf6e62d0c6a3439b4db11b50e5" title="Returns the start time of the manager.">Cudd_ReadStartTime</a> <a class="el" href="cuddAPI_8c.html#ac8bbaa787eb4bbf866292ea6f566e427" title="Resets the start time of the manager.">Cudd_ResetStartTime</a> <a class="el" href="cuddAPI_8c.html#ab6cafb71c46dedb3eaa27acd56b855b8" title="Returns the time elapsed since the start time of the manager.">Cudd_ReadElapsedTime</a> <a class="el" href="cuddAPI_8c.html#ac6e694e133632d34256646869f076ff5" title="Sets the time limit for the manager.">Cudd_SetTimeLimit</a> </dd></dl>

</div>
</div>
<a id="a910e7309dc7551140d71871619ead247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910e7309dc7551140d71871619ead247">&#9670;&nbsp;</a></span>Cudd_SetStderr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetStderr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the stderr of a manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a9830fe86096e7721263e058ba7d93d26" title="Reads the stderr of a manager.">Cudd_ReadStderr</a> <a class="el" href="cuddAPI_8c.html#ac3080103403d6ba1f79b04f4e701edbc" title="Sets the stdout of a manager.">Cudd_SetStdout</a> </dd></dl>

</div>
</div>
<a id="ac3080103403d6ba1f79b04f4e701edbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3080103403d6ba1f79b04f4e701edbc">&#9670;&nbsp;</a></span>Cudd_SetStdout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetStdout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the stdout of a manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a811b2599d1ed4a66001b7577cbbbd33d" title="Reads the stdout of a manager.">Cudd_ReadStdout</a> <a class="el" href="cuddAPI_8c.html#a910e7309dc7551140d71871619ead247" title="Sets the stderr of a manager.">Cudd_SetStderr</a> </dd></dl>

</div>
</div>
<a id="a5bb84b628160417172cb44e22e2067b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb84b628160417172cb44e22e2067b7">&#9670;&nbsp;</a></span>Cudd_SetSymmviolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetSymmviolation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>symmviolation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the symmviolation parameter used in group sifting. </p>
<p>This parameter is used in group sifting to decide how many violations to the symmetry conditions <code>f10 = f01</code> or <code>f11 = f00</code> are tolerable when checking for aggregation due to extended symmetry. The value should be between 0 and 100. A small value causes fewer variables to be aggregated. The default value is 0.</p>
<dl class="section user"><dt>Side effects\n Changes the manager.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a3028ccbe6fb46efd6565d0f4aab78738" title="Returns the current value of the symmviolation parameter used in group sifting.">Cudd_ReadSymmviolation</a> </dd></dl>

</div>
</div>
<a id="ac6e694e133632d34256646869f076ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e694e133632d34256646869f076ff5">&#9670;&nbsp;</a></span>Cudd_SetTimeLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Cudd_SetTimeLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>tl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the time limit for the manager. </p>
<p>The time must be expressed in milliseconds.</p>
<dl class="section return"><dt>Returns</dt><dd>the old time limit.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a855a253235b54ff16fd66c6e43241069" title="Returns the time limit for the manager.">Cudd_ReadTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aa497c8cb498833021f18813fb5813b57" title="Unsets the time limit for the manager.">Cudd_UnsetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aeeb6240810097270fd1414536de17eb0" title="Updates the time limit for the manager.">Cudd_UpdateTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a333169d352f3ab54002eaae738a39d68" title="Increases the time limit for the manager.">Cudd_IncreaseTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a7c3b2370790803f37aace1dfc0a7d1cc" title="Returns true if the time limit for the manager is set.">Cudd_TimeLimited</a> <a class="el" href="cuddAPI_8c.html#a2b42ab1fa12990140dbfd415bc7a6231" title="Sets the start time of the manager.">Cudd_SetStartTime</a> </dd></dl>

</div>
</div>
<a id="a2aa3827dfffcc29254520628b15aab55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa3827dfffcc29254520628b15aab55">&#9670;&nbsp;</a></span>Cudd_SetTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mtr_8h.html#ac77933bac85945a324b3ddacebbe899b">MtrNode</a> *&#160;</td>
          <td class="paramname"><em>tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the variable group tree of the manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#af5c6ecb39244a6db49494d1f1e31bd1a" title="Frees the variable group tree of the manager.">Cudd_FreeTree</a> <a class="el" href="cuddAPI_8c.html#a6ee8468f5b7fe67a0f609412e211632b" title="Returns the variable group tree of the manager.">Cudd_ReadTree</a> <a class="el" href="cuddAPI_8c.html#a2cdbbc9e78a4f0684a118f304eb1a455" title="Sets the ZDD variable group tree of the manager.">Cudd_SetZddTree</a> </dd></dl>

</div>
</div>
<a id="a2cdbbc9e78a4f0684a118f304eb1a455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdbbc9e78a4f0684a118f304eb1a455">&#9670;&nbsp;</a></span>Cudd_SetZddTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetZddTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mtr_8h.html#ac77933bac85945a324b3ddacebbe899b">MtrNode</a> *&#160;</td>
          <td class="paramname"><em>tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the ZDD variable group tree of the manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac9a25622e38ad302c050803d520f5fce" title="Frees the variable group tree of the manager.">Cudd_FreeZddTree</a> <a class="el" href="cuddAPI_8c.html#ad3d3dbe0fa509a7f70691dcb6d8726ad" title="Returns the variable group tree of the manager.">Cudd_ReadZddTree</a> <a class="el" href="cuddAPI_8c.html#a2aa3827dfffcc29254520628b15aab55" title="Sets the variable group tree of the manager.">Cudd_SetTree</a> </dd></dl>

</div>
</div>
<a id="aa3b17a13db3a9537a0a13df5507f4d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b17a13db3a9537a0a13df5507f4d11">&#9670;&nbsp;</a></span>Cudd_StdPostReordHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_StdPostReordHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample hook function to call after reordering. </p>
<p>Prints on the manager's stdout final size and reordering time.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a852da7502c07042fde873b504aaa4573" title="Sample hook function to call before reordering.">Cudd_StdPreReordHook</a> </dd></dl>

</div>
</div>
<a id="a852da7502c07042fde873b504aaa4573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852da7502c07042fde873b504aaa4573">&#9670;&nbsp;</a></span>Cudd_StdPreReordHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_StdPreReordHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample hook function to call before reordering. </p>
<p>Prints on the manager's stdout reordering method and initial size.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aa3b17a13db3a9537a0a13df5507f4d11" title="Sample hook function to call after reordering.">Cudd_StdPostReordHook</a> </dd></dl>

</div>
</div>
<a id="aeed52f5319f877acc6ac7c27490111b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed52f5319f877acc6ac7c27490111b6">&#9670;&nbsp;</a></span>Cudd_T()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_T </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the then child of an internal node. </p>
<p>If <code>node</code> is a constant node, the result is unpredictable.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a601a736699b3e5c8eb7149e6049ea131" title="Returns the else child of an internal node.">Cudd_E</a> <a class="el" href="cuddAPI_8c.html#a9ebe62ac5ac8a49dc13bce839ae09c88" title="Returns the value of a constant node.">Cudd_V</a> </dd></dl>

</div>
</div>
<a id="a7c3b2370790803f37aace1dfc0a7d1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3b2370790803f37aace1dfc0a7d1cc">&#9670;&nbsp;</a></span>Cudd_TimeLimited()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_TimeLimited </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the time limit for the manager is set. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a855a253235b54ff16fd66c6e43241069" title="Returns the time limit for the manager.">Cudd_ReadTimeLimit</a> <a class="el" href="cuddAPI_8c.html#ac6e694e133632d34256646869f076ff5" title="Sets the time limit for the manager.">Cudd_SetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aeeb6240810097270fd1414536de17eb0" title="Updates the time limit for the manager.">Cudd_UpdateTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aa497c8cb498833021f18813fb5813b57" title="Unsets the time limit for the manager.">Cudd_UnsetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a333169d352f3ab54002eaae738a39d68" title="Increases the time limit for the manager.">Cudd_IncreaseTimeLimit</a> </dd></dl>

</div>
</div>
<a id="a5b822894a35380ffca9e555286213484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b822894a35380ffca9e555286213484">&#9670;&nbsp;</a></span>Cudd_TurnOffCountDead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_TurnOffCountDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes the dead nodes not to be counted towards triggering reordering. </p>
<p>This causes less frequent reorderings. By default dead nodes are not counted. Therefore there is no need to call this function unless Cudd_TurnOnCountDead has been previously called.</p>
<dl class="section user"><dt>Side effects\n Changes the manager.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#af0b407453f68498df9b9783f88401cf5" title="Causes the dead nodes to be counted towards triggering reordering.">Cudd_TurnOnCountDead</a> <a class="el" href="cuddAPI_8c.html#ae34d186620ce66627e57bbccfa24a892" title="Tells whether dead nodes are counted towards triggering reordering.">Cudd_DeadAreCounted</a> </dd></dl>

</div>
</div>
<a id="af0b407453f68498df9b9783f88401cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b407453f68498df9b9783f88401cf5">&#9670;&nbsp;</a></span>Cudd_TurnOnCountDead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_TurnOnCountDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes the dead nodes to be counted towards triggering reordering. </p>
<p>This causes more frequent reorderings. By default dead nodes are not counted.</p>
<dl class="section user"><dt>Side effects\n Changes the manager.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a5b822894a35380ffca9e555286213484" title="Causes the dead nodes not to be counted towards triggering reordering.">Cudd_TurnOffCountDead</a> <a class="el" href="cuddAPI_8c.html#ae34d186620ce66627e57bbccfa24a892" title="Tells whether dead nodes are counted towards triggering reordering.">Cudd_DeadAreCounted</a> </dd></dl>

</div>
</div>
<a id="a1b6966d8f04f26fd49495f3703a771ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6966d8f04f26fd49495f3703a771ce">&#9670;&nbsp;</a></span>Cudd_UnregisterOutOfMemoryCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_UnregisterOutOfMemoryCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister an out-of-memory callback. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a6aa76d8075f1af649c8741af26369836" title="Installs an out-of-memory callback.">Cudd_RegisterOutOfMemoryCallback</a> <a class="el" href="cuddUtil_8c.html#a77cf07a23729b7f2621c74bf1e2ff830" title="Warns that a memory allocation failed.">Cudd_OutOfMem</a> <a class="el" href="cuddUtil_8c.html#aa6e655bc7b71ea719534f40fb8faa393" title="Doesn not warn that a memory allocation failed.">Cudd_OutOfMemSilent</a> </dd></dl>

</div>
</div>
<a id="a8014219cc6794497d58c3eeb140db8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8014219cc6794497d58c3eeb140db8c8">&#9670;&nbsp;</a></span>Cudd_UnregisterTerminationCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_UnregisterTerminationCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters a termination callback. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a5dbdd1ef4d92a8f7d60304e2cc17ff6e" title="Installs a termination callback.">Cudd_RegisterTerminationCallback</a> </dd></dl>

</div>
</div>
<a id="aa497c8cb498833021f18813fb5813b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa497c8cb498833021f18813fb5813b57">&#9670;&nbsp;</a></span>Cudd_UnsetTimeLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_UnsetTimeLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the time limit for the manager. </p>
<p>Actually, sets it to a very large value.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a855a253235b54ff16fd66c6e43241069" title="Returns the time limit for the manager.">Cudd_ReadTimeLimit</a> <a class="el" href="cuddAPI_8c.html#ac6e694e133632d34256646869f076ff5" title="Sets the time limit for the manager.">Cudd_SetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aeeb6240810097270fd1414536de17eb0" title="Updates the time limit for the manager.">Cudd_UpdateTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a333169d352f3ab54002eaae738a39d68" title="Increases the time limit for the manager.">Cudd_IncreaseTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a7c3b2370790803f37aace1dfc0a7d1cc" title="Returns true if the time limit for the manager is set.">Cudd_TimeLimited</a> <a class="el" href="cuddAPI_8c.html#a2b42ab1fa12990140dbfd415bc7a6231" title="Sets the start time of the manager.">Cudd_SetStartTime</a> </dd></dl>

</div>
</div>
<a id="aeeb6240810097270fd1414536de17eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb6240810097270fd1414536de17eb0">&#9670;&nbsp;</a></span>Cudd_UpdateTimeLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_UpdateTimeLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the time limit for the manager. </p>
<p>Updates the time limit for the manager by subtracting the elapsed time from it.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a855a253235b54ff16fd66c6e43241069" title="Returns the time limit for the manager.">Cudd_ReadTimeLimit</a> <a class="el" href="cuddAPI_8c.html#ac6e694e133632d34256646869f076ff5" title="Sets the time limit for the manager.">Cudd_SetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aa497c8cb498833021f18813fb5813b57" title="Unsets the time limit for the manager.">Cudd_UnsetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a333169d352f3ab54002eaae738a39d68" title="Increases the time limit for the manager.">Cudd_IncreaseTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a7c3b2370790803f37aace1dfc0a7d1cc" title="Returns true if the time limit for the manager is set.">Cudd_TimeLimited</a> <a class="el" href="cuddAPI_8c.html#a2b42ab1fa12990140dbfd415bc7a6231" title="Sets the start time of the manager.">Cudd_SetStartTime</a> </dd></dl>

</div>
</div>
<a id="a9ebe62ac5ac8a49dc13bce839ae09c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ebe62ac5ac8a49dc13bce839ae09c88">&#9670;&nbsp;</a></span>Cudd_V()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> Cudd_V </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of a constant node. </p>
<p>If <code>node</code> is an internal node, the result is unpredictable.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aeed52f5319f877acc6ac7c27490111b6" title="Returns the then child of an internal node.">Cudd_T</a> <a class="el" href="cuddAPI_8c.html#a601a736699b3e5c8eb7149e6049ea131" title="Returns the else child of an internal node.">Cudd_E</a> </dd></dl>

</div>
</div>
<a id="acbf8017813ae9a60790ae4f8a445800d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf8017813ae9a60790ae4f8a445800d">&#9670;&nbsp;</a></span>Cudd_zddIthVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddIthVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ZDD variable with index i. </p>
<p>Retrieves the ZDD variable with index i if it already exists, or creates a new ZDD variable.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the variable if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a40fd71665cde402bd5bc4f39015c09ae" title="Returns the BDD variable with index i.">Cudd_bddIthVar</a> <a class="el" href="cuddAPI_8c.html#a19967d7c87650f63fc312f38c318e3e9" title="Returns the ADD variable with index i.">Cudd_addIthVar</a> </dd></dl>

</div>
</div>
<a id="a4c015c746d9c71fb9b57249f2a4ccd72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c015c746d9c71fb9b57249f2a4ccd72">&#9670;&nbsp;</a></span>Cudd_zddReadNodeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Cudd_zddReadNodeCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the number of nodes in ZDDs. </p>
<p>This number always includes the two constants 1 and 0.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a39633df05be731b6b145d65f83aed572" title="Reports the peak number of nodes.">Cudd_ReadPeakNodeCount</a> <a class="el" href="cuddAPI_8c.html#a9ba2c88b8f70df51791c26ffde800fc7" title="Reports the number of nodes in BDDs and ADDs.">Cudd_ReadNodeCount</a> </dd></dl>

</div>
</div>
<a id="afea01466660ca226539a66a014a4da00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea01466660ca226539a66a014a4da00">&#9670;&nbsp;</a></span>Cudd_zddRealignDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_zddRealignDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables realignment of ZDD order to BDD order. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aa57aff1886a1fea0cb8b5bf8d66cf50e" title="Enables realignment of ZDD order to BDD order.">Cudd_zddRealignEnable</a> <a class="el" href="cuddAPI_8c.html#a34225975eef55170213a0a9efed5a891" title="Tells whether the realignment of ZDD order to BDD order is enabled.">Cudd_zddRealignmentEnabled</a> <a class="el" href="cuddAPI_8c.html#a2d0d34d836668fc62e7c7835fa95132d" title="Enables realignment of BDD order to ZDD order.">Cudd_bddRealignEnable</a> <a class="el" href="cuddAPI_8c.html#a516183604a75b38337b81fd17c291826" title="Tells whether the realignment of BDD order to ZDD order is enabled.">Cudd_bddRealignmentEnabled</a> </dd></dl>

</div>
</div>
<a id="aa57aff1886a1fea0cb8b5bf8d66cf50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57aff1886a1fea0cb8b5bf8d66cf50e">&#9670;&nbsp;</a></span>Cudd_zddRealignEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_zddRealignEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables realignment of ZDD order to BDD order. </p>
<p>Enables realignment of the ZDD variable order to the BDD variable order after the BDDs and ADDs have been reordered. The number of ZDD variables must be a multiple of the number of BDD variables for realignment to make sense. If this condition is not met, Cudd_ReduceHeap will return 0. Let <code>M</code> be the ratio of the two numbers. For the purpose of realignment, the ZDD variables from <code>M*i</code> to <code>(M+1)*i-1</code> are reagarded as corresponding to BDD variable <code>i</code>. Realignment is initially disabled.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddReorder_8c.html#a02a5a86dfb8ebc7726d6cf56b6a7eec1" title="Main dynamic reordering routine.">Cudd_ReduceHeap</a> <a class="el" href="cuddAPI_8c.html#afea01466660ca226539a66a014a4da00" title="Disables realignment of ZDD order to BDD order.">Cudd_zddRealignDisable</a> <a class="el" href="cuddAPI_8c.html#a34225975eef55170213a0a9efed5a891" title="Tells whether the realignment of ZDD order to BDD order is enabled.">Cudd_zddRealignmentEnabled</a> <a class="el" href="cuddAPI_8c.html#a3eb093bdd80db0b880f61017f3e36de2" title="Disables realignment of ZDD order to BDD order.">Cudd_bddRealignDisable</a> <a class="el" href="cuddAPI_8c.html#a516183604a75b38337b81fd17c291826" title="Tells whether the realignment of BDD order to ZDD order is enabled.">Cudd_bddRealignmentEnabled</a> </dd></dl>

</div>
</div>
<a id="a34225975eef55170213a0a9efed5a891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34225975eef55170213a0a9efed5a891">&#9670;&nbsp;</a></span>Cudd_zddRealignmentEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_zddRealignmentEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether the realignment of ZDD order to BDD order is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the realignment of ZDD order to BDD order is enabled; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aa57aff1886a1fea0cb8b5bf8d66cf50e" title="Enables realignment of ZDD order to BDD order.">Cudd_zddRealignEnable</a> <a class="el" href="cuddAPI_8c.html#afea01466660ca226539a66a014a4da00" title="Disables realignment of ZDD order to BDD order.">Cudd_zddRealignDisable</a> <a class="el" href="cuddAPI_8c.html#a2d0d34d836668fc62e7c7835fa95132d" title="Enables realignment of BDD order to ZDD order.">Cudd_bddRealignEnable</a> <a class="el" href="cuddAPI_8c.html#a3eb093bdd80db0b880f61017f3e36de2" title="Disables realignment of ZDD order to BDD order.">Cudd_bddRealignDisable</a> </dd></dl>

</div>
</div>
<a id="a45d898e3087539ceaaf5ff86aa62c471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d898e3087539ceaaf5ff86aa62c471">&#9670;&nbsp;</a></span>Cudd_zddVarsFromBddVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_zddVarsFromBddVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>multiplicity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates one or more ZDD variables for each BDD variable. </p>
<p>If some ZDD variables already exist, only the missing variables are created. Parameter multiplicity allows the caller to control how many variables are created for each BDD variable in existence. For instance, if ZDDs are used to represent covers, two ZDD variables are required for each BDD variable. The order of the BDD variables is transferred to the ZDD variables. If a variable group tree exists for the BDD variables, a corresponding ZDD variable group tree is created by expanding the BDD variable tree. In any case, the ZDD variables derived from the same BDD variable are merged in a ZDD variable group. If a ZDD variable group tree exists, it is freed.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a475c50e1a273569cc0ffc19ab98c28ce" title="Returns a new BDD variable.">Cudd_bddNewVar</a> <a class="el" href="cuddAPI_8c.html#a40fd71665cde402bd5bc4f39015c09ae" title="Returns the BDD variable with index i.">Cudd_bddIthVar</a> <a class="el" href="cuddAPI_8c.html#ae35eac7df807101795efe0d582ff05fa" title="Returns a new BDD variable at a specified level.">Cudd_bddNewVarAtLevel</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">multiplicity</td><td>how many ZDD variables are created for each BDD variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a7571d0ca349667f3912593b8a7d8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7571d0ca349667f3912593b8a7d8d1">&#9670;&nbsp;</a></span>fixVarTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fixVarTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mtr_8h.html#ac77933bac85945a324b3ddacebbe899b">MtrNode</a> *&#160;</td>
          <td class="paramname"><em>treenode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fixes a variable group tree. </p>
<dl class="section user"><dt>Side effects\n Changes the variable group tree.</dt><dd></dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 2 2019 17:00:50 for cudd by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
